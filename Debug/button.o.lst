   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"button.c"
  21              	.Ltext0:
  22              		.file 1 "../button.c"
 2979              		.align	2
 2981              	celda_poner_valor:
 2982              	.LFB1:
   1:../celda.h    **** 	/* guarda para evitar inclusiones mÃºltiples (include guard) */
   2:../celda.h    **** 	#ifndef CELDA_H
   3:../celda.h    **** 	#define CELDA_H
   4:../celda.h    **** 	
   5:../celda.h    **** 	#include <inttypes.h>
   6:../celda.h    **** 	
   7:../celda.h    **** 	/* Cada celda se codifica en 16 bits
   8:../celda.h    **** 	 * bits [15,7]: los 9 bits mÃ¡s significativos representan el vector de candidatos,
   9:../celda.h    **** 	 * si el bit 7 + valor - 1 estÃ¡ a 0, valor es candidato, 1 en caso contrario
  10:../celda.h    **** 	 * bit 6: no empleado
  11:../celda.h    **** 	 * bit 5: error
  12:../celda.h    **** 	 * bit 4: pista
  13:../celda.h    **** 	 * bits [3,0]: valor de la celda
  14:../celda.h    **** 	 */
  15:../celda.h    **** 	
  16:../celda.h    **** enum { BIT_CANDIDATOS = 7, BIT_NO_USADO = 6, BIT_ERROR = 5, BIT_PISTA = 4 };
  17:../celda.h    **** 	
  18:../celda.h    **** 	typedef uint16_t CELDA;
  19:../celda.h    **** 	
  20:../celda.h    **** 	/* *****************************************************************************
  21:../celda.h    **** 	 * elimina el candidato del valor almacenado en la celda indicada */
  22:../celda.h    **** 	__inline static void
  23:../celda.h    **** 	celda_eliminar_candidato(CELDA *celdaptr, uint8_t valor)
  24:../celda.h    **** 	{
  25:../celda.h    **** 		*celdaptr = *celdaptr | (0x0001 << (BIT_CANDIDATOS + valor - 1));
  26:../celda.h    **** 	}
  27:../celda.h    **** 	
  28:../celda.h    **** 	/* *****************************************************************************
  29:../celda.h    **** 	 * modifica el valor almacenado en la celda indicada */
  30:../celda.h    **** 	__inline static void
  31:../celda.h    **** 	celda_poner_valor(CELDA *celdaptr, uint8_t val)
  32:../celda.h    **** 	{
 2983              		.loc 17 32 0
 2984              		.cfi_startproc
 2985              		@ Function supports interworking.
 2986              		@ args = 0, pretend = 0, frame = 8
 2987              		@ frame_needed = 1, uses_anonymous_args = 0
 2988 0000 0DC0A0E1 		mov	ip, sp
 2989              	.LCFI0:
 2990              		.cfi_def_cfa_register 12
 2991 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2992 0008 04B04CE2 		sub	fp, ip, #4
 2993              		.cfi_offset 14, -8
 2994              		.cfi_offset 13, -12
 2995              		.cfi_offset 11, -16
 2996              	.LCFI1:
 2997              		.cfi_def_cfa 11, 4
 2998 000c 08D04DE2 		sub	sp, sp, #8
 2999 0010 10000BE5 		str	r0, [fp, #-16]
 3000 0014 0130A0E1 		mov	r3, r1
 3001 0018 11304BE5 		strb	r3, [fp, #-17]
  33:../celda.h    **** 		*celdaptr = (*celdaptr & 0xFFF0) | (val & 0x000F);
 3002              		.loc 17 33 0
 3003 001c 10301BE5 		ldr	r3, [fp, #-16]
 3004 0020 B030D3E1 		ldrh	r3, [r3, #0]
 3005 0024 0338A0E1 		mov	r3, r3, asl #16
 3006 0028 2338A0E1 		mov	r3, r3, lsr #16
 3007 002c 0F30C3E3 		bic	r3, r3, #15
 3008 0030 0338A0E1 		mov	r3, r3, asl #16
 3009 0034 2328A0E1 		mov	r2, r3, lsr #16
 3010 0038 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3011 003c 0338A0E1 		mov	r3, r3, asl #16
 3012 0040 2338A0E1 		mov	r3, r3, lsr #16
 3013 0044 0F3003E2 		and	r3, r3, #15
 3014 0048 0338A0E1 		mov	r3, r3, asl #16
 3015 004c 2338A0E1 		mov	r3, r3, lsr #16
 3016 0050 033082E1 		orr	r3, r2, r3
 3017 0054 0338A0E1 		mov	r3, r3, asl #16
 3018 0058 2338A0E1 		mov	r3, r3, lsr #16
 3019 005c 0338A0E1 		mov	r3, r3, asl #16
 3020 0060 2328A0E1 		mov	r2, r3, lsr #16
 3021 0064 10301BE5 		ldr	r3, [fp, #-16]
 3022 0068 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  34:../celda.h    **** 	}
 3023              		.loc 17 34 0
 3024 006c 0CD04BE2 		sub	sp, fp, #12
 3025 0070 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3026 0074 1EFF2FE1 		bx	lr
 3027              		.cfi_endproc
 3028              	.LFE1:
 3030              		.align	2
 3032              	celda_leer_valor:
 3033              	.LFB2:
  35:../celda.h    **** 	
  36:../celda.h    **** 	/* *****************************************************************************
  37:../celda.h    **** 	 * extrae el valor almacenado en los 16 bits de una celda */
  38:../celda.h    ****         __inline static uint8_t
  39:../celda.h    ****         celda_leer_valor(CELDA celda)
  40:../celda.h    ****         {
 3034              		.loc 17 40 0
 3035              		.cfi_startproc
 3036              		@ Function supports interworking.
 3037              		@ args = 0, pretend = 0, frame = 8
 3038              		@ frame_needed = 1, uses_anonymous_args = 0
 3039 0078 0DC0A0E1 		mov	ip, sp
 3040              	.LCFI2:
 3041              		.cfi_def_cfa_register 12
 3042 007c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3043 0080 04B04CE2 		sub	fp, ip, #4
 3044              		.cfi_offset 14, -8
 3045              		.cfi_offset 13, -12
 3046              		.cfi_offset 11, -16
 3047              	.LCFI3:
 3048              		.cfi_def_cfa 11, 4
 3049 0084 08D04DE2 		sub	sp, sp, #8
 3050 0088 0030A0E1 		mov	r3, r0
 3051 008c BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  41:../celda.h    ****                 return (celda & 0x000F);
 3052              		.loc 17 41 0
 3053 0090 BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 3054 0094 FF3003E2 		and	r3, r3, #255
 3055 0098 0F3003E2 		and	r3, r3, #15
 3056 009c FF3003E2 		and	r3, r3, #255
  42:../celda.h    ****         }
 3057              		.loc 17 42 0
 3058 00a0 0300A0E1 		mov	r0, r3
 3059 00a4 0CD04BE2 		sub	sp, fp, #12
 3060 00a8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3061 00ac 1EFF2FE1 		bx	lr
 3062              		.cfi_endproc
 3063              	.LFE2:
 3065              		.align	2
 3067              	celda_es_candidato:
 3068              	.LFB3:
  43:../celda.h    **** 
  44:../celda.h    ****         /* *****************************************************************************
  45:../celda.h    ****          * comprueba si el valor es candidato en la celda indicada */
  46:../celda.h    ****         __inline static int
  47:../celda.h    ****         celda_es_candidato(CELDA celda, uint8_t valor)
  48:../celda.h    ****         {
 3069              		.loc 17 48 0
 3070              		.cfi_startproc
 3071              		@ Function supports interworking.
 3072              		@ args = 0, pretend = 0, frame = 8
 3073              		@ frame_needed = 1, uses_anonymous_args = 0
 3074 00b0 0DC0A0E1 		mov	ip, sp
 3075              	.LCFI4:
 3076              		.cfi_def_cfa_register 12
 3077 00b4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3078 00b8 04B04CE2 		sub	fp, ip, #4
 3079              		.cfi_offset 14, -8
 3080              		.cfi_offset 13, -12
 3081              		.cfi_offset 11, -16
 3082              	.LCFI5:
 3083              		.cfi_def_cfa 11, 4
 3084 00bc 08D04DE2 		sub	sp, sp, #8
 3085 00c0 0020A0E1 		mov	r2, r0
 3086 00c4 0130A0E1 		mov	r3, r1
 3087 00c8 BE204BE1 		strh	r2, [fp, #-14]	@ movhi
 3088 00cc 0F304BE5 		strb	r3, [fp, #-15]
  49:../celda.h    ****                 return (celda & (0x0001 << (BIT_CANDIDATOS + valor - 1))) == 0;
 3089              		.loc 17 49 0
 3090 00d0 BE205BE1 		ldrh	r2, [fp, #-14]
 3091 00d4 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3092 00d8 063083E2 		add	r3, r3, #6
 3093 00dc 5233A0E1 		mov	r3, r2, asr r3
 3094 00e0 013003E2 		and	r3, r3, #1
 3095 00e4 000053E3 		cmp	r3, #0
 3096 00e8 0030A013 		movne	r3, #0
 3097 00ec 0130A003 		moveq	r3, #1
  50:../celda.h    ****         }
 3098              		.loc 17 50 0
 3099 00f0 0300A0E1 		mov	r0, r3
 3100 00f4 0CD04BE2 		sub	sp, fp, #12
 3101 00f8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3102 00fc 1EFF2FE1 		bx	lr
 3103              		.cfi_endproc
 3104              	.LFE3:
 3106              		.align	2
 3108              	celda_es_pista:
 3109              	.LFB4:
  51:../celda.h    **** 
  52:../celda.h    ****         /* *****************************************************************************
  53:../celda.h    ****          * comprueba si la celda es una pista */
  54:../celda.h    ****         __inline static int
  55:../celda.h    ****         celda_es_pista(CELDA celda)
  56:../celda.h    ****         {
 3110              		.loc 17 56 0
 3111              		.cfi_startproc
 3112              		@ Function supports interworking.
 3113              		@ args = 0, pretend = 0, frame = 8
 3114              		@ frame_needed = 1, uses_anonymous_args = 0
 3115 0100 0DC0A0E1 		mov	ip, sp
 3116              	.LCFI6:
 3117              		.cfi_def_cfa_register 12
 3118 0104 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3119 0108 04B04CE2 		sub	fp, ip, #4
 3120              		.cfi_offset 14, -8
 3121              		.cfi_offset 13, -12
 3122              		.cfi_offset 11, -16
 3123              	.LCFI7:
 3124              		.cfi_def_cfa 11, 4
 3125 010c 08D04DE2 		sub	sp, sp, #8
 3126 0110 0030A0E1 		mov	r3, r0
 3127 0114 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  57:../celda.h    ****                 return (celda & (1 << BIT_PISTA)) != 0;
 3128              		.loc 17 57 0
 3129 0118 BE305BE1 		ldrh	r3, [fp, #-14]
 3130 011c 103003E2 		and	r3, r3, #16
 3131 0120 000053E3 		cmp	r3, #0
 3132 0124 0030A003 		moveq	r3, #0
 3133 0128 0130A013 		movne	r3, #1
  58:../celda.h    ****         }
 3134              		.loc 17 58 0
 3135 012c 0300A0E1 		mov	r0, r3
 3136 0130 0CD04BE2 		sub	sp, fp, #12
 3137 0134 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3138 0138 1EFF2FE1 		bx	lr
 3139              		.cfi_endproc
 3140              	.LFE4:
 3142              		.align	2
 3144              	celda_marcar_error:
 3145              	.LFB5:
  59:../celda.h    **** 
  60:../celda.h    ****         /* *****************************************************************************
  61:../celda.h    ****          * marca o limpia el bit de error de la celda */
  62:../celda.h    ****         __inline static void
  63:../celda.h    ****         celda_marcar_error(CELDA *celdaptr)
  64:../celda.h    ****         {
 3146              		.loc 17 64 0
 3147              		.cfi_startproc
 3148              		@ Function supports interworking.
 3149              		@ args = 0, pretend = 0, frame = 8
 3150              		@ frame_needed = 1, uses_anonymous_args = 0
 3151 013c 0DC0A0E1 		mov	ip, sp
 3152              	.LCFI8:
 3153              		.cfi_def_cfa_register 12
 3154 0140 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3155 0144 04B04CE2 		sub	fp, ip, #4
 3156              		.cfi_offset 14, -8
 3157              		.cfi_offset 13, -12
 3158              		.cfi_offset 11, -16
 3159              	.LCFI9:
 3160              		.cfi_def_cfa 11, 4
 3161 0148 08D04DE2 		sub	sp, sp, #8
 3162 014c 10000BE5 		str	r0, [fp, #-16]
  65:../celda.h    ****                 *celdaptr |= (1 << BIT_ERROR);
 3163              		.loc 17 65 0
 3164 0150 10301BE5 		ldr	r3, [fp, #-16]
 3165 0154 B030D3E1 		ldrh	r3, [r3, #0]
 3166 0158 203083E3 		orr	r3, r3, #32
 3167 015c 0338A0E1 		mov	r3, r3, asl #16
 3168 0160 2328A0E1 		mov	r2, r3, lsr #16
 3169 0164 10301BE5 		ldr	r3, [fp, #-16]
 3170 0168 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  66:../celda.h    ****         }
 3171              		.loc 17 66 0
 3172 016c 0CD04BE2 		sub	sp, fp, #12
 3173 0170 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3174 0174 1EFF2FE1 		bx	lr
 3175              		.cfi_endproc
 3176              	.LFE5:
 3178              		.align	2
 3180              	celda_limpiar_error:
 3181              	.LFB6:
  67:../celda.h    **** 
  68:../celda.h    ****         __inline static void
  69:../celda.h    ****         celda_limpiar_error(CELDA *celdaptr)
  70:../celda.h    ****         {
 3182              		.loc 17 70 0
 3183              		.cfi_startproc
 3184              		@ Function supports interworking.
 3185              		@ args = 0, pretend = 0, frame = 8
 3186              		@ frame_needed = 1, uses_anonymous_args = 0
 3187 0178 0DC0A0E1 		mov	ip, sp
 3188              	.LCFI10:
 3189              		.cfi_def_cfa_register 12
 3190 017c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3191 0180 04B04CE2 		sub	fp, ip, #4
 3192              		.cfi_offset 14, -8
 3193              		.cfi_offset 13, -12
 3194              		.cfi_offset 11, -16
 3195              	.LCFI11:
 3196              		.cfi_def_cfa 11, 4
 3197 0184 08D04DE2 		sub	sp, sp, #8
 3198 0188 10000BE5 		str	r0, [fp, #-16]
  71:../celda.h    ****                 *celdaptr &= ~(1 << BIT_ERROR);
 3199              		.loc 17 71 0
 3200 018c 10301BE5 		ldr	r3, [fp, #-16]
 3201 0190 B030D3E1 		ldrh	r3, [r3, #0]
 3202 0194 2030C3E3 		bic	r3, r3, #32
 3203 0198 0338A0E1 		mov	r3, r3, asl #16
 3204 019c 2328A0E1 		mov	r2, r3, lsr #16
 3205 01a0 10301BE5 		ldr	r3, [fp, #-16]
 3206 01a4 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  72:../celda.h    ****         }
 3207              		.loc 17 72 0
 3208 01a8 0CD04BE2 		sub	sp, fp, #12
 3209 01ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3210 01b0 1EFF2FE1 		bx	lr
 3211              		.cfi_endproc
 3212              	.LFE6:
 3214              		.bss
 3215              	estado_juego:
 3216 0000 00       		.space	1
 3217              	int_count:
 3218 0001 00       		.space	1
 3219              	fila:
 3220 0002 00       		.space	1
 3221              	columna:
 3222 0003 00       		.space	1
 3223              	valor:
 3224 0004 00       		.space	1
 3225              	valor_previo:
 3226 0005 00       		.space	1
 3227              	pantalla_mostrada:
 3228 0006 00       		.space	1
 3229 0007 00       		.align	2
 3230              	tiempo_inicio:
 3231 0008 00000000 		.space	4
 3232              		.align	2
 3233              	tiempo_final:
 3234 000c 00000000 		.space	4
 3235              		.text
 3236              		.align	2
 3238              	marcar_celdas_en_conflicto:
 3239              	.LFB7:
   1:../button.c   **** /*********************************************************************************************
   2:../button.c   **** * Fichero:      button.c
   3:../button.c   **** * Autor:
   4:../button.c   **** * Descrip:      Funciones de manejo de los pulsadores (EINT6-7)
   5:../button.c   **** * Version:
   6:../button.c   **** *********************************************************************************************/
   7:../button.c   **** 
   8:../button.c   **** /*--- ficheros de cabecera ---*/
   9:../button.c   **** #include "button.h"
  10:../button.c   **** #include "8led.h"
  11:../button.c   **** #include "cola.h"
  12:../button.c   **** #include "eventos.h"
  13:../button.c   **** #include "timer2.h"
  14:../button.c   **** #include "timer3.h"
  15:../button.c   **** #include "44blib.h"
  16:../button.c   **** #include "44b.h"
  17:../button.c   **** #include "def.h"
  18:../button.c   **** #include "sudoku_2025.h"
  19:../button.c   **** #include "lcd.h"
  20:../button.c   **** 
  21:../button.c   **** /*--- Variables del juego Sudoku ---*/
  22:../button.c   **** static volatile EstadoSudoku estado_juego = ESPERANDO_INICIO;
  23:../button.c   **** static volatile uint8_t int_count = 0;
  24:../button.c   **** static volatile uint8_t fila = 0;
  25:../button.c   **** static volatile uint8_t columna = 0;
  26:../button.c   **** static volatile uint8_t valor = 0;
  27:../button.c   **** static volatile uint8_t valor_previo = 0;  /* Para detectar modificación de valor */
  28:../button.c   **** static volatile uint8_t pantalla_mostrada = 0;  /* Flag para mostrar pantalla inicial solo una vez 
  29:../button.c   **** static volatile uint32_t tiempo_inicio = 0;  /* Tiempo de inicio de la partida actual */
  30:../button.c   **** static volatile uint32_t tiempo_final = 0;  /* Tiempo final al terminar la partida */
  31:../button.c   **** 
  32:../button.c   **** /* Declaración externa de la cuadrícula del juego */
  33:../button.c   **** extern CELDA (*cuadricula)[NUM_COLUMNAS];
  34:../button.c   **** extern int celdas_vacias;
  35:../button.c   **** 
  36:../button.c   **** /* Función auxiliar para marcar todas las celdas en conflicto con un valor */
  37:../button.c   **** static void marcar_celdas_en_conflicto(uint8_t fila_error, uint8_t col_error, uint8_t valor_error)
  38:../button.c   **** {
 3240              		.loc 1 38 0
 3241              		.cfi_startproc
 3242              		@ Function supports interworking.
 3243              		@ args = 0, pretend = 0, frame = 16
 3244              		@ frame_needed = 1, uses_anonymous_args = 0
 3245 01b4 0DC0A0E1 		mov	ip, sp
 3246              	.LCFI12:
 3247              		.cfi_def_cfa_register 12
 3248 01b8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3249 01bc 04B04CE2 		sub	fp, ip, #4
 3250              		.cfi_offset 14, -8
 3251              		.cfi_offset 13, -12
 3252              		.cfi_offset 11, -16
 3253              	.LCFI13:
 3254              		.cfi_def_cfa 11, 4
 3255 01c0 10D04DE2 		sub	sp, sp, #16
 3256 01c4 0230A0E1 		mov	r3, r2
 3257 01c8 0020A0E1 		mov	r2, r0
 3258 01cc 15204BE5 		strb	r2, [fp, #-21]
 3259 01d0 0120A0E1 		mov	r2, r1
 3260 01d4 16204BE5 		strb	r2, [fp, #-22]
 3261 01d8 17304BE5 		strb	r3, [fp, #-23]
  39:../button.c   **** 	uint8_t i, f, c;
  40:../button.c   **** 	uint8_t region_fila_inicio, region_col_inicio;
  41:../button.c   **** 	
  42:../button.c   **** 	/* Primero limpiar todos los errores previos */
  43:../button.c   **** 	for (f = 0; f < NUM_FILAS; f++)
 3262              		.loc 1 43 0
 3263 01dc 0030A0E3 		mov	r3, #0
 3264 01e0 0E304BE5 		strb	r3, [fp, #-14]
 3265 01e4 160000EA 		b	.L8
 3266              	.L11:
  44:../button.c   **** 	{
  45:../button.c   **** 		for (c = 0; c < NUM_COLUMNAS; c++)
 3267              		.loc 1 45 0
 3268 01e8 0030A0E3 		mov	r3, #0
 3269 01ec 0F304BE5 		strb	r3, [fp, #-15]
 3270 01f0 0D0000EA 		b	.L9
 3271              	.L10:
  46:../button.c   **** 		{
  47:../button.c   **** 			celda_limpiar_error(&cuadricula[f][c]);
 3272              		.loc 1 47 0 discriminator 2
 3273 01f4 EC329FE5 		ldr	r3, .L24
 3274 01f8 003093E5 		ldr	r3, [r3, #0]
 3275 01fc 0320A0E1 		mov	r2, r3
 3276 0200 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3277 0204 0312A0E1 		mov	r1, r3, asl #4
 3278 0208 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3279 020c 033081E0 		add	r3, r1, r3
 3280 0210 8330A0E1 		mov	r3, r3, asl #1
 3281 0214 033082E0 		add	r3, r2, r3
 3282 0218 0300A0E1 		mov	r0, r3
 3283 021c D5FFFFEB 		bl	celda_limpiar_error
  45:../button.c   **** 		for (c = 0; c < NUM_COLUMNAS; c++)
 3284              		.loc 1 45 0 discriminator 2
 3285 0220 0F305BE5 		ldrb	r3, [fp, #-15]
 3286 0224 013083E2 		add	r3, r3, #1
 3287 0228 0F304BE5 		strb	r3, [fp, #-15]
 3288              	.L9:
  45:../button.c   **** 		for (c = 0; c < NUM_COLUMNAS; c++)
 3289              		.loc 1 45 0 is_stmt 0 discriminator 1
 3290 022c 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3291 0230 0F0053E3 		cmp	r3, #15
 3292 0234 EEFFFF9A 		bls	.L10
  43:../button.c   **** 	for (f = 0; f < NUM_FILAS; f++)
 3293              		.loc 1 43 0 is_stmt 1
 3294 0238 0E305BE5 		ldrb	r3, [fp, #-14]
 3295 023c 013083E2 		add	r3, r3, #1
 3296 0240 0E304BE5 		strb	r3, [fp, #-14]
 3297              	.L8:
  43:../button.c   **** 	for (f = 0; f < NUM_FILAS; f++)
 3298              		.loc 1 43 0 is_stmt 0 discriminator 1
 3299 0244 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3300 0248 080053E3 		cmp	r3, #8
 3301 024c E5FFFF9A 		bls	.L11
  48:../button.c   **** 		}
  49:../button.c   **** 	}
  50:../button.c   **** 	
  51:../button.c   **** 	/* Marcar la celda donde intentamos poner el valor */
  52:../button.c   **** 	celda_marcar_error(&cuadricula[fila_error][col_error]);
 3302              		.loc 1 52 0 is_stmt 1
 3303 0250 90329FE5 		ldr	r3, .L24
 3304 0254 003093E5 		ldr	r3, [r3, #0]
 3305 0258 0320A0E1 		mov	r2, r3
 3306 025c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3307 0260 0312A0E1 		mov	r1, r3, asl #4
 3308 0264 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3309 0268 033081E0 		add	r3, r1, r3
 3310 026c 8330A0E1 		mov	r3, r3, asl #1
 3311 0270 033082E0 		add	r3, r2, r3
 3312 0274 0300A0E1 		mov	r0, r3
 3313 0278 AFFFFFEB 		bl	celda_marcar_error
  53:../button.c   **** 	
  54:../button.c   **** 	/* Buscar y marcar todas las celdas con el mismo valor en la misma fila */
  55:../button.c   **** 	for (i = 0; i < NUM_COLUMNAS; i++)
 3314              		.loc 1 55 0
 3315 027c 0030A0E3 		mov	r3, #0
 3316 0280 0D304BE5 		strb	r3, [fp, #-13]
 3317 0284 200000EA 		b	.L12
 3318              	.L14:
  56:../button.c   **** 	{
  57:../button.c   **** 		if (i != col_error && celda_leer_valor(cuadricula[fila_error][i]) == valor_error)
 3319              		.loc 1 57 0
 3320 0288 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 3321 028c 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3322 0290 030052E1 		cmp	r2, r3
 3323 0294 1900000A 		beq	.L13
 3324              		.loc 1 57 0 is_stmt 0 discriminator 1
 3325 0298 48329FE5 		ldr	r3, .L24
 3326 029c 002093E5 		ldr	r2, [r3, #0]
 3327 02a0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3328 02a4 8332A0E1 		mov	r3, r3, asl #5
 3329 02a8 032082E0 		add	r2, r2, r3
 3330 02ac 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3331 02b0 8330A0E1 		mov	r3, r3, asl #1
 3332 02b4 033082E0 		add	r3, r2, r3
 3333 02b8 B030D3E1 		ldrh	r3, [r3, #0]
 3334 02bc 0300A0E1 		mov	r0, r3
 3335 02c0 6CFFFFEB 		bl	celda_leer_valor
 3336 02c4 0030A0E1 		mov	r3, r0
 3337 02c8 17205BE5 		ldrb	r2, [fp, #-23]	@ zero_extendqisi2
 3338 02cc 030052E1 		cmp	r2, r3
 3339 02d0 0A00001A 		bne	.L13
  58:../button.c   **** 		{
  59:../button.c   **** 			celda_marcar_error(&cuadricula[fila_error][i]);
 3340              		.loc 1 59 0 is_stmt 1
 3341 02d4 0C329FE5 		ldr	r3, .L24
 3342 02d8 003093E5 		ldr	r3, [r3, #0]
 3343 02dc 0320A0E1 		mov	r2, r3
 3344 02e0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3345 02e4 0312A0E1 		mov	r1, r3, asl #4
 3346 02e8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3347 02ec 033081E0 		add	r3, r1, r3
 3348 02f0 8330A0E1 		mov	r3, r3, asl #1
 3349 02f4 033082E0 		add	r3, r2, r3
 3350 02f8 0300A0E1 		mov	r0, r3
 3351 02fc 8EFFFFEB 		bl	celda_marcar_error
 3352              	.L13:
  55:../button.c   **** 	for (i = 0; i < NUM_COLUMNAS; i++)
 3353              		.loc 1 55 0
 3354 0300 0D305BE5 		ldrb	r3, [fp, #-13]
 3355 0304 013083E2 		add	r3, r3, #1
 3356 0308 0D304BE5 		strb	r3, [fp, #-13]
 3357              	.L12:
  55:../button.c   **** 	for (i = 0; i < NUM_COLUMNAS; i++)
 3358              		.loc 1 55 0 is_stmt 0 discriminator 1
 3359 030c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3360 0310 0F0053E3 		cmp	r3, #15
 3361 0314 DBFFFF9A 		bls	.L14
  60:../button.c   **** 		}
  61:../button.c   **** 	}
  62:../button.c   **** 	
  63:../button.c   **** 	/* Buscar y marcar todas las celdas con el mismo valor en la misma columna */
  64:../button.c   **** 	for (i = 0; i < NUM_FILAS; i++)
 3362              		.loc 1 64 0 is_stmt 1
 3363 0318 0030A0E3 		mov	r3, #0
 3364 031c 0D304BE5 		strb	r3, [fp, #-13]
 3365 0320 200000EA 		b	.L15
 3366              	.L17:
  65:../button.c   **** 	{
  66:../button.c   **** 		if (i != fila_error && celda_leer_valor(cuadricula[i][col_error]) == valor_error)
 3367              		.loc 1 66 0
 3368 0324 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 3369 0328 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3370 032c 030052E1 		cmp	r2, r3
 3371 0330 1900000A 		beq	.L16
 3372              		.loc 1 66 0 is_stmt 0 discriminator 1
 3373 0334 AC319FE5 		ldr	r3, .L24
 3374 0338 002093E5 		ldr	r2, [r3, #0]
 3375 033c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3376 0340 8332A0E1 		mov	r3, r3, asl #5
 3377 0344 032082E0 		add	r2, r2, r3
 3378 0348 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3379 034c 8330A0E1 		mov	r3, r3, asl #1
 3380 0350 033082E0 		add	r3, r2, r3
 3381 0354 B030D3E1 		ldrh	r3, [r3, #0]
 3382 0358 0300A0E1 		mov	r0, r3
 3383 035c 45FFFFEB 		bl	celda_leer_valor
 3384 0360 0030A0E1 		mov	r3, r0
 3385 0364 17205BE5 		ldrb	r2, [fp, #-23]	@ zero_extendqisi2
 3386 0368 030052E1 		cmp	r2, r3
 3387 036c 0A00001A 		bne	.L16
  67:../button.c   **** 		{
  68:../button.c   **** 			celda_marcar_error(&cuadricula[i][col_error]);
 3388              		.loc 1 68 0 is_stmt 1
 3389 0370 70319FE5 		ldr	r3, .L24
 3390 0374 003093E5 		ldr	r3, [r3, #0]
 3391 0378 0320A0E1 		mov	r2, r3
 3392 037c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3393 0380 0312A0E1 		mov	r1, r3, asl #4
 3394 0384 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3395 0388 033081E0 		add	r3, r1, r3
 3396 038c 8330A0E1 		mov	r3, r3, asl #1
 3397 0390 033082E0 		add	r3, r2, r3
 3398 0394 0300A0E1 		mov	r0, r3
 3399 0398 67FFFFEB 		bl	celda_marcar_error
 3400              	.L16:
  64:../button.c   **** 	for (i = 0; i < NUM_FILAS; i++)
 3401              		.loc 1 64 0
 3402 039c 0D305BE5 		ldrb	r3, [fp, #-13]
 3403 03a0 013083E2 		add	r3, r3, #1
 3404 03a4 0D304BE5 		strb	r3, [fp, #-13]
 3405              	.L15:
  64:../button.c   **** 	for (i = 0; i < NUM_FILAS; i++)
 3406              		.loc 1 64 0 is_stmt 0 discriminator 1
 3407 03a8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3408 03ac 080053E3 		cmp	r3, #8
 3409 03b0 DBFFFF9A 		bls	.L17
  69:../button.c   **** 		}
  70:../button.c   **** 	}
  71:../button.c   **** 	
  72:../button.c   **** 	/* Buscar y marcar todas las celdas con el mismo valor en la misma región 3x3 */
  73:../button.c   **** 	region_fila_inicio = (fila_error / 3) * 3;
 3410              		.loc 1 73 0 is_stmt 1
 3411 03b4 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 3412 03b8 2C319FE5 		ldr	r3, .L24+4
 3413 03bc 921383E0 		umull	r1, r3, r2, r3
 3414 03c0 A330A0E1 		mov	r3, r3, lsr #1
 3415 03c4 FF3003E2 		and	r3, r3, #255
 3416 03c8 0320A0E1 		mov	r2, r3
 3417 03cc 8220A0E1 		mov	r2, r2, asl #1
 3418 03d0 033082E0 		add	r3, r2, r3
 3419 03d4 10304BE5 		strb	r3, [fp, #-16]
  74:../button.c   **** 	region_col_inicio = (col_error / 3) * 3;
 3420              		.loc 1 74 0
 3421 03d8 16205BE5 		ldrb	r2, [fp, #-22]	@ zero_extendqisi2
 3422 03dc 08319FE5 		ldr	r3, .L24+4
 3423 03e0 921383E0 		umull	r1, r3, r2, r3
 3424 03e4 A330A0E1 		mov	r3, r3, lsr #1
 3425 03e8 FF3003E2 		and	r3, r3, #255
 3426 03ec 0320A0E1 		mov	r2, r3
 3427 03f0 8220A0E1 		mov	r2, r2, asl #1
 3428 03f4 033082E0 		add	r3, r2, r3
 3429 03f8 11304BE5 		strb	r3, [fp, #-17]
  75:../button.c   **** 	
  76:../button.c   **** 	for (f = region_fila_inicio; f < region_fila_inicio + 3; f++)
 3430              		.loc 1 76 0
 3431 03fc 10305BE5 		ldrb	r3, [fp, #-16]
 3432 0400 0E304BE5 		strb	r3, [fp, #-14]
 3433 0404 2F0000EA 		b	.L18
 3434              	.L23:
  77:../button.c   **** 	{
  78:../button.c   **** 		for (c = region_col_inicio; c < region_col_inicio + 3; c++)
 3435              		.loc 1 78 0
 3436 0408 11305BE5 		ldrb	r3, [fp, #-17]
 3437 040c 0F304BE5 		strb	r3, [fp, #-15]
 3438 0410 240000EA 		b	.L19
 3439              	.L22:
  79:../button.c   **** 		{
  80:../button.c   **** 			if ((f != fila_error || c != col_error) && celda_leer_valor(cuadricula[f][c]) == valor_error)
 3440              		.loc 1 80 0
 3441 0414 0E205BE5 		ldrb	r2, [fp, #-14]	@ zero_extendqisi2
 3442 0418 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3443 041c 030052E1 		cmp	r2, r3
 3444 0420 0300001A 		bne	.L20
 3445              		.loc 1 80 0 is_stmt 0 discriminator 2
 3446 0424 0F205BE5 		ldrb	r2, [fp, #-15]	@ zero_extendqisi2
 3447 0428 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3448 042c 030052E1 		cmp	r2, r3
 3449 0430 1900000A 		beq	.L21
 3450              	.L20:
 3451              		.loc 1 80 0 discriminator 1
 3452 0434 AC309FE5 		ldr	r3, .L24
 3453 0438 002093E5 		ldr	r2, [r3, #0]
 3454 043c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3455 0440 8332A0E1 		mov	r3, r3, asl #5
 3456 0444 032082E0 		add	r2, r2, r3
 3457 0448 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3458 044c 8330A0E1 		mov	r3, r3, asl #1
 3459 0450 033082E0 		add	r3, r2, r3
 3460 0454 B030D3E1 		ldrh	r3, [r3, #0]
 3461 0458 0300A0E1 		mov	r0, r3
 3462 045c 05FFFFEB 		bl	celda_leer_valor
 3463 0460 0030A0E1 		mov	r3, r0
 3464 0464 17205BE5 		ldrb	r2, [fp, #-23]	@ zero_extendqisi2
 3465 0468 030052E1 		cmp	r2, r3
 3466 046c 0A00001A 		bne	.L21
  81:../button.c   **** 			{
  82:../button.c   **** 				celda_marcar_error(&cuadricula[f][c]);
 3467              		.loc 1 82 0 is_stmt 1
 3468 0470 70309FE5 		ldr	r3, .L24
 3469 0474 003093E5 		ldr	r3, [r3, #0]
 3470 0478 0320A0E1 		mov	r2, r3
 3471 047c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3472 0480 0312A0E1 		mov	r1, r3, asl #4
 3473 0484 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3474 0488 033081E0 		add	r3, r1, r3
 3475 048c 8330A0E1 		mov	r3, r3, asl #1
 3476 0490 033082E0 		add	r3, r2, r3
 3477 0494 0300A0E1 		mov	r0, r3
 3478 0498 27FFFFEB 		bl	celda_marcar_error
 3479              	.L21:
  78:../button.c   **** 		for (c = region_col_inicio; c < region_col_inicio + 3; c++)
 3480              		.loc 1 78 0
 3481 049c 0F305BE5 		ldrb	r3, [fp, #-15]
 3482 04a0 013083E2 		add	r3, r3, #1
 3483 04a4 0F304BE5 		strb	r3, [fp, #-15]
 3484              	.L19:
  78:../button.c   **** 		for (c = region_col_inicio; c < region_col_inicio + 3; c++)
 3485              		.loc 1 78 0 is_stmt 0 discriminator 1
 3486 04a8 0F205BE5 		ldrb	r2, [fp, #-15]	@ zero_extendqisi2
 3487 04ac 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3488 04b0 033083E2 		add	r3, r3, #3
 3489 04b4 030052E1 		cmp	r2, r3
 3490 04b8 D5FFFFBA 		blt	.L22
  76:../button.c   **** 	for (f = region_fila_inicio; f < region_fila_inicio + 3; f++)
 3491              		.loc 1 76 0 is_stmt 1
 3492 04bc 0E305BE5 		ldrb	r3, [fp, #-14]
 3493 04c0 013083E2 		add	r3, r3, #1
 3494 04c4 0E304BE5 		strb	r3, [fp, #-14]
 3495              	.L18:
  76:../button.c   **** 	for (f = region_fila_inicio; f < region_fila_inicio + 3; f++)
 3496              		.loc 1 76 0 is_stmt 0 discriminator 1
 3497 04c8 0E205BE5 		ldrb	r2, [fp, #-14]	@ zero_extendqisi2
 3498 04cc 10305BE5 		ldrb	r3, [fp, #-16]	@ zero_extendqisi2
 3499 04d0 033083E2 		add	r3, r3, #3
 3500 04d4 030052E1 		cmp	r2, r3
 3501 04d8 CAFFFFBA 		blt	.L23
  83:../button.c   **** 			}
  84:../button.c   **** 		}
  85:../button.c   **** 	}
  86:../button.c   **** }
 3502              		.loc 1 86 0 is_stmt 1
 3503 04dc 0CD04BE2 		sub	sp, fp, #12
 3504 04e0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3505 04e4 1EFF2FE1 		bx	lr
 3506              	.L25:
 3507              		.align	2
 3508              	.L24:
 3509 04e8 00000000 		.word	cuadricula
 3510 04ec ABAAAAAA 		.word	-1431655765
 3511              		.cfi_endproc
 3512              	.LFE7:
 3514              		.align	2
 3516              	boton_confirmado:
 3517              	.LFB8:
  87:../button.c   **** 
  88:../button.c   **** /* Callback para recibir la confirmación de pulsaciones filtradas por el timer3 */
  89:../button.c   **** static void boton_confirmado(uint8_t boton_id) // MODIFICAR FUNCIONES ACTUALIZAR Y PROPAGAR SEGUN L
  90:../button.c   **** {
 3518              		.loc 1 90 0
 3519              		.cfi_startproc
 3520              		@ Function supports interworking.
 3521              		@ args = 0, pretend = 0, frame = 16
 3522              		@ frame_needed = 1, uses_anonymous_args = 0
 3523 04f0 0DC0A0E1 		mov	ip, sp
 3524              	.LCFI14:
 3525              		.cfi_def_cfa_register 12
 3526 04f4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3527 04f8 04B04CE2 		sub	fp, ip, #4
 3528              		.cfi_offset 14, -8
 3529              		.cfi_offset 13, -12
 3530              		.cfi_offset 11, -16
 3531              	.LCFI15:
 3532              		.cfi_def_cfa 11, 4
 3533 04fc 10D04DE2 		sub	sp, sp, #16
 3534 0500 0030A0E1 		mov	r3, r0
 3535 0504 15304BE5 		strb	r3, [fp, #-21]
  91:../button.c   ****         cola_depuracion(timer2_count(), boton_id, estado_juego);
 3536              		.loc 1 91 0
 3537 0508 FEFFFFEB 		bl	timer2_count
 3538 050c 0010A0E1 		mov	r1, r0
 3539 0510 88389FE5 		ldr	r3, .L68
 3540 0514 0030D3E5 		ldrb	r3, [r3, #0]
 3541 0518 FF3003E2 		and	r3, r3, #255
 3542 051c 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 3543 0520 0100A0E1 		mov	r0, r1
 3544 0524 0210A0E1 		mov	r1, r2
 3545 0528 0320A0E1 		mov	r2, r3
 3546 052c FEFFFFEB 		bl	cola_depuracion
  92:../button.c   ****         
  93:../button.c   ****         switch (estado_juego)
 3547              		.loc 1 93 0
 3548 0530 68389FE5 		ldr	r3, .L68
 3549 0534 0030D3E5 		ldrb	r3, [r3, #0]
 3550 0538 FF3003E2 		and	r3, r3, #255
 3551 053c 070053E3 		cmp	r3, #7
 3552 0540 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3553 0544 120200EA 		b	.L26
 3554              	.L35:
 3555 0548 68050000 		.word	.L28
 3556 054c D8050000 		.word	.L29
 3557 0550 C8060000 		.word	.L30
 3558 0554 88070000 		.word	.L31
 3559 0558 10080000 		.word	.L32
 3560 055c B0080000 		.word	.L33
 3561 0560 940D0000 		.word	.L26
 3562 0564 200D0000 		.word	.L34
 3563              	.L28:
  94:../button.c   ****         {
  95:../button.c   ****                 case ESPERANDO_INICIO:
  96:../button.c   ****                         /* Cualquier botón inicia el juego */
  97:../button.c   ****                         /* Guardar tiempo de inicio para reiniciar el contador */
  98:../button.c   ****                         tiempo_inicio = timer2_count();
 3564              		.loc 1 98 0
 3565 0568 FEFFFFEB 		bl	timer2_count
 3566 056c 0020A0E1 		mov	r2, r0
 3567 0570 2C389FE5 		ldr	r3, .L68+4
 3568 0574 002083E5 		str	r2, [r3, #0]
  99:../button.c   ****                         
 100:../button.c   ****                         /* Calcular candidatos por primera vez */
 101:../button.c   ****                         celdas_vacias = candidatos_actualizar_all(cuadricula);
 3569              		.loc 1 101 0
 3570 0578 28389FE5 		ldr	r3, .L68+8
 3571 057c 003093E5 		ldr	r3, [r3, #0]
 3572 0580 0300A0E1 		mov	r0, r3
 3573 0584 FEFFFFEB 		bl	candidatos_actualizar_all
 3574 0588 0020A0E1 		mov	r2, r0
 3575 058c 18389FE5 		ldr	r3, .L68+12
 3576 0590 002083E5 		str	r2, [r3, #0]
 102:../button.c   ****                         
 103:../button.c   ****                         /* Dibujar el tablero del juego */
 104:../button.c   ****                         Sudoku_Dibujar_Tablero();
 3577              		.loc 1 104 0
 3578 0594 FEFFFFEB 		bl	Sudoku_Dibujar_Tablero
 105:../button.c   ****                         
 106:../button.c   ****                         /* Actualizar con los valores de la cuadrícula */
 107:../button.c   ****                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3579              		.loc 1 107 0
 3580 0598 08389FE5 		ldr	r3, .L68+8
 3581 059c 003093E5 		ldr	r3, [r3, #0]
 3582 05a0 0300A0E1 		mov	r0, r3
 3583 05a4 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 108:../button.c   ****                         
 109:../button.c   ****                         /* Pasar a introducir fila */
 110:../button.c   ****                         estado_juego = INTRODUCIR_FILA;
 3584              		.loc 1 110 0
 3585 05a8 F0379FE5 		ldr	r3, .L68
 3586 05ac 0120A0E3 		mov	r2, #1
 3587 05b0 0020C3E5 		strb	r2, [r3, #0]
 111:../button.c   ****                         int_count = 9;  /* Iniciar en 9 para que al incrementar vaya a 0 */
 3588              		.loc 1 111 0
 3589 05b4 F4379FE5 		ldr	r3, .L68+16
 3590 05b8 0920A0E3 		mov	r2, #9
 3591 05bc 0020C3E5 		strb	r2, [r3, #0]
 112:../button.c   ****                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3592              		.loc 1 112 0
 3593 05c0 0F00A0E3 		mov	r0, #15
 3594 05c4 FEFFFFEB 		bl	D8Led_symbol
 113:../button.c   ****                         pantalla_mostrada = 0;  /* Resetear flag para próxima partida */
 3595              		.loc 1 113 0
 3596 05c8 E4379FE5 		ldr	r3, .L68+20
 3597 05cc 0020A0E3 		mov	r2, #0
 3598 05d0 0020C3E5 		strb	r2, [r3, #0]
 114:../button.c   ****                         break;
 3599              		.loc 1 114 0
 3600 05d4 EE0100EA 		b	.L26
 3601              	.L29:
 115:../button.c   ****                 
 116:../button.c   ****                 case INTRODUCIR_FILA:
 117:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3602              		.loc 1 117 0
 3603 05d8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3604 05dc 080053E3 		cmp	r3, #8
 3605 05e0 1500001A 		bne	.L36
 118:../button.c   ****                         {
 119:../button.c   ****                                 /* Incrementar fila (ciclo: 0 → 1 → 2 → ... → 9 → 0) */
 120:../button.c   ****                                 int_count++;
 3606              		.loc 1 120 0
 3607 05e4 C4379FE5 		ldr	r3, .L68+16
 3608 05e8 0030D3E5 		ldrb	r3, [r3, #0]
 3609 05ec FF3003E2 		and	r3, r3, #255
 3610 05f0 013083E2 		add	r3, r3, #1
 3611 05f4 FF2003E2 		and	r2, r3, #255
 3612 05f8 B0379FE5 		ldr	r3, .L68+16
 3613 05fc 0020C3E5 		strb	r2, [r3, #0]
 121:../button.c   ****                                 if (int_count > 9)
 3614              		.loc 1 121 0
 3615 0600 A8379FE5 		ldr	r3, .L68+16
 3616 0604 0030D3E5 		ldrb	r3, [r3, #0]
 3617 0608 FF3003E2 		and	r3, r3, #255
 3618 060c 090053E3 		cmp	r3, #9
 3619 0610 0200009A 		bls	.L37
 122:../button.c   ****                                 {
 123:../button.c   ****                                         int_count = 0;  /* Volver a 0 */
 3620              		.loc 1 123 0
 3621 0614 94379FE5 		ldr	r3, .L68+16
 3622 0618 0020A0E3 		mov	r2, #0
 3623 061c 0020C3E5 		strb	r2, [r3, #0]
 3624              	.L37:
 124:../button.c   ****                                 }
 125:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3625              		.loc 1 125 0
 3626 0620 88379FE5 		ldr	r3, .L68+16
 3627 0624 0030D3E5 		ldrb	r3, [r3, #0]
 3628 0628 FF3003E2 		and	r3, r3, #255
 3629 062c 0F3003E2 		and	r3, r3, #15
 3630 0630 0300A0E1 		mov	r0, r3
 3631 0634 FEFFFFEB 		bl	D8Led_symbol
 126:../button.c   ****                         }
 127:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 128:../button.c   ****                         {
 129:../button.c   ****                                 /* Verificar si se eligió fila 0 (terminar partida) */
 130:../button.c   ****                                 if (int_count == 0)
 131:../button.c   ****                                 {
 132:../button.c   ****                                         /* Fila 0: terminar la partida */
 133:../button.c   ****                                         /* Guardar tiempo transcurrido desde el inicio de esta part
 134:../button.c   ****                                         tiempo_final = timer2_count() - tiempo_inicio;
 135:../button.c   ****                                         estado_juego = PARTIDA_TERMINADA;
 136:../button.c   ****                                         /* La pantalla final se mostrará en este estado */
 137:../button.c   ****                                 }
 138:../button.c   ****                                 else
 139:../button.c   ****                                 {
 140:../button.c   ****                                         /* Confirmar fila y pasar a introducir columna */
 141:../button.c   ****                                         fila = int_count - 1;  /* Convertir a índice 0-8 */
 142:../button.c   ****                                         estado_juego = INTRODUCIR_COLUMNA;
 143:../button.c   ****                                         int_count = 0;
 144:../button.c   ****                                         D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en
 145:../button.c   ****                                 }
 146:../button.c   ****                         }
 147:../button.c   ****                         break;
 3632              		.loc 1 147 0
 3633 0638 D50100EA 		b	.L26
 3634              	.L36:
 127:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3635              		.loc 1 127 0
 3636 063c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3637 0640 040053E3 		cmp	r3, #4
 3638 0644 CD01001A 		bne	.L65
 130:../button.c   ****                                 if (int_count == 0)
 3639              		.loc 1 130 0
 3640 0648 60379FE5 		ldr	r3, .L68+16
 3641 064c 0030D3E5 		ldrb	r3, [r3, #0]
 3642 0650 FF3003E2 		and	r3, r3, #255
 3643 0654 000053E3 		cmp	r3, #0
 3644 0658 0A00001A 		bne	.L39
 134:../button.c   ****                                         tiempo_final = timer2_count() - tiempo_inicio;
 3645              		.loc 1 134 0
 3646 065c FEFFFFEB 		bl	timer2_count
 3647 0660 0020A0E1 		mov	r2, r0
 3648 0664 38379FE5 		ldr	r3, .L68+4
 3649 0668 003093E5 		ldr	r3, [r3, #0]
 3650 066c 022063E0 		rsb	r2, r3, r2
 3651 0670 40379FE5 		ldr	r3, .L68+24
 3652 0674 002083E5 		str	r2, [r3, #0]
 135:../button.c   ****                                         estado_juego = PARTIDA_TERMINADA;
 3653              		.loc 1 135 0
 3654 0678 20379FE5 		ldr	r3, .L68
 3655 067c 0720A0E3 		mov	r2, #7
 3656 0680 0020C3E5 		strb	r2, [r3, #0]
 3657              		.loc 1 147 0
 3658 0684 C20100EA 		b	.L26
 3659              	.L39:
 141:../button.c   ****                                         fila = int_count - 1;  /* Convertir a índice 0-8 */
 3660              		.loc 1 141 0
 3661 0688 20379FE5 		ldr	r3, .L68+16
 3662 068c 0030D3E5 		ldrb	r3, [r3, #0]
 3663 0690 FF3003E2 		and	r3, r3, #255
 3664 0694 013043E2 		sub	r3, r3, #1
 3665 0698 FF2003E2 		and	r2, r3, #255
 3666 069c 18379FE5 		ldr	r3, .L68+28
 3667 06a0 0020C3E5 		strb	r2, [r3, #0]
 142:../button.c   ****                                         estado_juego = INTRODUCIR_COLUMNA;
 3668              		.loc 1 142 0
 3669 06a4 F4369FE5 		ldr	r3, .L68
 3670 06a8 0220A0E3 		mov	r2, #2
 3671 06ac 0020C3E5 		strb	r2, [r3, #0]
 143:../button.c   ****                                         int_count = 0;
 3672              		.loc 1 143 0
 3673 06b0 F8369FE5 		ldr	r3, .L68+16
 3674 06b4 0020A0E3 		mov	r2, #0
 3675 06b8 0020C3E5 		strb	r2, [r3, #0]
 144:../button.c   ****                                         D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en
 3676              		.loc 1 144 0
 3677 06bc 0C00A0E3 		mov	r0, #12
 3678 06c0 FEFFFFEB 		bl	D8Led_symbol
 3679              		.loc 1 147 0
 3680 06c4 B20100EA 		b	.L26
 3681              	.L30:
 148:../button.c   ****                 
 149:../button.c   ****                 case INTRODUCIR_COLUMNA:
 150:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3682              		.loc 1 150 0
 3683 06c8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3684 06cc 080053E3 		cmp	r3, #8
 3685 06d0 1500001A 		bne	.L40
 151:../button.c   ****                         {
 152:../button.c   ****                                 /* Incrementar columna */
 153:../button.c   ****                                 int_count++;
 3686              		.loc 1 153 0
 3687 06d4 D4369FE5 		ldr	r3, .L68+16
 3688 06d8 0030D3E5 		ldrb	r3, [r3, #0]
 3689 06dc FF3003E2 		and	r3, r3, #255
 3690 06e0 013083E2 		add	r3, r3, #1
 3691 06e4 FF2003E2 		and	r2, r3, #255
 3692 06e8 C0369FE5 		ldr	r3, .L68+16
 3693 06ec 0020C3E5 		strb	r2, [r3, #0]
 154:../button.c   ****                                 if (int_count > 9)
 3694              		.loc 1 154 0
 3695 06f0 B8369FE5 		ldr	r3, .L68+16
 3696 06f4 0030D3E5 		ldrb	r3, [r3, #0]
 3697 06f8 FF3003E2 		and	r3, r3, #255
 3698 06fc 090053E3 		cmp	r3, #9
 3699 0700 0200009A 		bls	.L41
 155:../button.c   ****                                 {
 156:../button.c   ****                                         int_count = 1;
 3700              		.loc 1 156 0
 3701 0704 A4369FE5 		ldr	r3, .L68+16
 3702 0708 0120A0E3 		mov	r2, #1
 3703 070c 0020C3E5 		strb	r2, [r3, #0]
 3704              	.L41:
 157:../button.c   ****                                 }
 158:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3705              		.loc 1 158 0
 3706 0710 98369FE5 		ldr	r3, .L68+16
 3707 0714 0030D3E5 		ldrb	r3, [r3, #0]
 3708 0718 FF3003E2 		and	r3, r3, #255
 3709 071c 0F3003E2 		and	r3, r3, #15
 3710 0720 0300A0E1 		mov	r0, r3
 3711 0724 FEFFFFEB 		bl	D8Led_symbol
 159:../button.c   ****                         }
 160:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 161:../button.c   ****                         {
 162:../button.c   ****                                 /* Confirmar columna y pasar a introducir valor */
 163:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
 164:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
 165:../button.c   ****                                 int_count = 0;
 166:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 167:../button.c   ****                         }
 168:../button.c   ****                         break;
 3712              		.loc 1 168 0
 3713 0728 990100EA 		b	.L26
 3714              	.L40:
 160:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3715              		.loc 1 160 0
 3716 072c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3717 0730 040053E3 		cmp	r3, #4
 3718 0734 9301001A 		bne	.L66
 163:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
 3719              		.loc 1 163 0
 3720 0738 70369FE5 		ldr	r3, .L68+16
 3721 073c 0030D3E5 		ldrb	r3, [r3, #0]
 3722 0740 FF3003E2 		and	r3, r3, #255
 3723 0744 013043E2 		sub	r3, r3, #1
 3724 0748 FF2003E2 		and	r2, r3, #255
 3725 074c 6C369FE5 		ldr	r3, .L68+32
 3726 0750 0020C3E5 		strb	r2, [r3, #0]
 164:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
 3727              		.loc 1 164 0
 3728 0754 44369FE5 		ldr	r3, .L68
 3729 0758 0320A0E3 		mov	r2, #3
 3730 075c 0020C3E5 		strb	r2, [r3, #0]
 165:../button.c   ****                                 int_count = 0;
 3731              		.loc 1 165 0
 3732 0760 48369FE5 		ldr	r3, .L68+16
 3733 0764 0020A0E3 		mov	r2, #0
 3734 0768 0020C3E5 		strb	r2, [r3, #0]
 166:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3735              		.loc 1 166 0
 3736 076c 3C369FE5 		ldr	r3, .L68+16
 3737 0770 0030D3E5 		ldrb	r3, [r3, #0]
 3738 0774 FF3003E2 		and	r3, r3, #255
 3739 0778 0F3003E2 		and	r3, r3, #15
 3740 077c 0300A0E1 		mov	r0, r3
 3741 0780 FEFFFFEB 		bl	D8Led_symbol
 3742              		.loc 1 168 0
 3743 0784 820100EA 		b	.L26
 3744              	.L31:
 169:../button.c   ****                 
 170:../button.c   ****                 case VERIFICAR_CELDA:
 171:../button.c   ****                         /* Primero se verifica si la celda[fila][columna] no es una pista */
 172:../button.c   ****                         if (celda_es_pista(cuadricula[fila][columna]))
 3745              		.loc 1 172 0
 3746 0788 18369FE5 		ldr	r3, .L68+8
 3747 078c 002093E5 		ldr	r2, [r3, #0]
 3748 0790 24369FE5 		ldr	r3, .L68+28
 3749 0794 0030D3E5 		ldrb	r3, [r3, #0]
 3750 0798 FF3003E2 		and	r3, r3, #255
 3751 079c 8332A0E1 		mov	r3, r3, asl #5
 3752 07a0 032082E0 		add	r2, r2, r3
 3753 07a4 14369FE5 		ldr	r3, .L68+32
 3754 07a8 0030D3E5 		ldrb	r3, [r3, #0]
 3755 07ac FF3003E2 		and	r3, r3, #255
 3756 07b0 8330A0E1 		mov	r3, r3, asl #1
 3757 07b4 033082E0 		add	r3, r2, r3
 3758 07b8 B030D3E1 		ldrh	r3, [r3, #0]
 3759 07bc 0300A0E1 		mov	r0, r3
 3760 07c0 4EFEFFEB 		bl	celda_es_pista
 3761 07c4 0030A0E1 		mov	r3, r0
 3762 07c8 000053E3 		cmp	r3, #0
 3763 07cc 0800000A 		beq	.L43
 173:../button.c   ****                         {
 174:../button.c   ****                                 // Se vuelve al estado INTRODUCIR_FILA
 175:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3764              		.loc 1 175 0
 3765 07d0 C8359FE5 		ldr	r3, .L68
 3766 07d4 0120A0E3 		mov	r2, #1
 3767 07d8 0020C3E5 		strb	r2, [r3, #0]
 176:../button.c   ****                                 int_count = 0;
 3768              		.loc 1 176 0
 3769 07dc CC359FE5 		ldr	r3, .L68+16
 3770 07e0 0020A0E3 		mov	r2, #0
 3771 07e4 0020C3E5 		strb	r2, [r3, #0]
 177:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila (índice 15 en el array S
 3772              		.loc 1 177 0
 3773 07e8 0F00A0E3 		mov	r0, #15
 3774 07ec FEFFFFEB 		bl	D8Led_symbol
 178:../button.c   ****                         } 
 179:../button.c   ****                         else
 180:../button.c   ****                         {
 181:../button.c   ****                                 // Si no es pista, se pasa a INTRODUCIR_VALOR
 182:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 183:../button.c   ****                                 int_count = 0;
 184:../button.c   ****                         }
 185:../button.c   ****                         break;
 3775              		.loc 1 185 0
 3776 07f0 670100EA 		b	.L26
 3777              	.L43:
 182:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 3778              		.loc 1 182 0
 3779 07f4 A4359FE5 		ldr	r3, .L68
 3780 07f8 0420A0E3 		mov	r2, #4
 3781 07fc 0020C3E5 		strb	r2, [r3, #0]
 183:../button.c   ****                                 int_count = 0;
 3782              		.loc 1 183 0
 3783 0800 A8359FE5 		ldr	r3, .L68+16
 3784 0804 0020A0E3 		mov	r2, #0
 3785 0808 0020C3E5 		strb	r2, [r3, #0]
 3786              		.loc 1 185 0
 3787 080c 600100EA 		b	.L26
 3788              	.L32:
 186:../button.c   ****                 
 187:../button.c   ****                 case INTRODUCIR_VALOR:
 188:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3789              		.loc 1 188 0
 3790 0810 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3791 0814 080053E3 		cmp	r3, #8
 3792 0818 1500001A 		bne	.L45
 189:../button.c   ****                         {
 190:../button.c   ****                                 /* Incrementar valor */
 191:../button.c   ****                                 int_count++;
 3793              		.loc 1 191 0
 3794 081c 8C359FE5 		ldr	r3, .L68+16
 3795 0820 0030D3E5 		ldrb	r3, [r3, #0]
 3796 0824 FF3003E2 		and	r3, r3, #255
 3797 0828 013083E2 		add	r3, r3, #1
 3798 082c FF2003E2 		and	r2, r3, #255
 3799 0830 78359FE5 		ldr	r3, .L68+16
 3800 0834 0020C3E5 		strb	r2, [r3, #0]
 192:../button.c   ****                                 if (int_count > 9)
 3801              		.loc 1 192 0
 3802 0838 70359FE5 		ldr	r3, .L68+16
 3803 083c 0030D3E5 		ldrb	r3, [r3, #0]
 3804 0840 FF3003E2 		and	r3, r3, #255
 3805 0844 090053E3 		cmp	r3, #9
 3806 0848 0200009A 		bls	.L46
 193:../button.c   ****                                 {
 194:../button.c   ****                                         int_count = 0;
 3807              		.loc 1 194 0
 3808 084c 5C359FE5 		ldr	r3, .L68+16
 3809 0850 0020A0E3 		mov	r2, #0
 3810 0854 0020C3E5 		strb	r2, [r3, #0]
 3811              	.L46:
 195:../button.c   ****                                 }
 196:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3812              		.loc 1 196 0
 3813 0858 50359FE5 		ldr	r3, .L68+16
 3814 085c 0030D3E5 		ldrb	r3, [r3, #0]
 3815 0860 FF3003E2 		and	r3, r3, #255
 3816 0864 0F3003E2 		and	r3, r3, #15
 3817 0868 0300A0E1 		mov	r0, r3
 3818 086c FEFFFFEB 		bl	D8Led_symbol
 197:../button.c   ****                         }
 198:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 199:../button.c   ****                         {
 200:../button.c   ****                                 /* Confirmar valor e intentar escribir en la celda */
 201:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 202:../button.c   ****                                 
 203:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 204:../button.c   ****                                 int_count = 0;
 205:../button.c   ****                         }
 206:../button.c   ****                         break;
 3819              		.loc 1 206 0
 3820 0870 470100EA 		b	.L26
 3821              	.L45:
 198:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3822              		.loc 1 198 0
 3823 0874 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3824 0878 040053E3 		cmp	r3, #4
 3825 087c 4301001A 		bne	.L67
 201:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 3826              		.loc 1 201 0
 3827 0880 28359FE5 		ldr	r3, .L68+16
 3828 0884 0030D3E5 		ldrb	r3, [r3, #0]
 3829 0888 FF2003E2 		and	r2, r3, #255
 3830 088c 30359FE5 		ldr	r3, .L68+36
 3831 0890 0020C3E5 		strb	r2, [r3, #0]
 203:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 3832              		.loc 1 203 0
 3833 0894 04359FE5 		ldr	r3, .L68
 3834 0898 0520A0E3 		mov	r2, #5
 3835 089c 0020C3E5 		strb	r2, [r3, #0]
 204:../button.c   ****                                 int_count = 0;
 3836              		.loc 1 204 0
 3837 08a0 08359FE5 		ldr	r3, .L68+16
 3838 08a4 0020A0E3 		mov	r2, #0
 3839 08a8 0020C3E5 		strb	r2, [r3, #0]
 3840              		.loc 1 206 0
 3841 08ac 380100EA 		b	.L26
 3842              	.L33:
 207:../button.c   ****                 
 208:../button.c   ****                 case VERIFICAR_VALOR:
 209:../button.c   ****                         /* Guardar valor previo de la celda */
 210:../button.c   ****                         valor_previo = celda_leer_valor(cuadricula[fila][columna]);
 3843              		.loc 1 210 0
 3844 08b0 F0349FE5 		ldr	r3, .L68+8
 3845 08b4 002093E5 		ldr	r2, [r3, #0]
 3846 08b8 FC349FE5 		ldr	r3, .L68+28
 3847 08bc 0030D3E5 		ldrb	r3, [r3, #0]
 3848 08c0 FF3003E2 		and	r3, r3, #255
 3849 08c4 8332A0E1 		mov	r3, r3, asl #5
 3850 08c8 032082E0 		add	r2, r2, r3
 3851 08cc EC349FE5 		ldr	r3, .L68+32
 3852 08d0 0030D3E5 		ldrb	r3, [r3, #0]
 3853 08d4 FF3003E2 		and	r3, r3, #255
 3854 08d8 8330A0E1 		mov	r3, r3, asl #1
 3855 08dc 033082E0 		add	r3, r2, r3
 3856 08e0 B030D3E1 		ldrh	r3, [r3, #0]
 3857 08e4 0300A0E1 		mov	r0, r3
 3858 08e8 E2FDFFEB 		bl	celda_leer_valor
 3859 08ec 0030A0E1 		mov	r3, r0
 3860 08f0 0320A0E1 		mov	r2, r3
 3861 08f4 CC349FE5 		ldr	r3, .L68+40
 3862 08f8 0020C3E5 		strb	r2, [r3, #0]
 211:../button.c   ****                         
 212:../button.c   ****                         if (valor == 0)
 3863              		.loc 1 212 0
 3864 08fc C0349FE5 		ldr	r3, .L68+36
 3865 0900 0030D3E5 		ldrb	r3, [r3, #0]
 3866 0904 FF3003E2 		and	r3, r3, #255
 3867 0908 000053E3 		cmp	r3, #0
 3868 090c 4000001A 		bne	.L48
 3869              	.LBB2:
 213:../button.c   ****                         {
 214:../button.c   ****                                 uint8_t f, c;
 215:../button.c   ****                                 
 216:../button.c   ****                                 /* Valor 0 = borrar -> pasar a BORRAR_VALOR */
 217:../button.c   ****                                 /* Limpiar todos los errores previos */
 218:../button.c   ****                                 for (f = 0; f < NUM_FILAS; f++)
 3870              		.loc 1 218 0
 3871 0910 0030A0E3 		mov	r3, #0
 3872 0914 0D304BE5 		strb	r3, [fp, #-13]
 3873 0918 160000EA 		b	.L49
 3874              	.L52:
 219:../button.c   ****                                 {
 220:../button.c   ****                                         for (c = 0; c < NUM_COLUMNAS; c++)
 3875              		.loc 1 220 0
 3876 091c 0030A0E3 		mov	r3, #0
 3877 0920 0E304BE5 		strb	r3, [fp, #-14]
 3878 0924 0D0000EA 		b	.L50
 3879              	.L51:
 221:../button.c   ****                                         {
 222:../button.c   ****                                                 celda_limpiar_error(&cuadricula[f][c]);
 3880              		.loc 1 222 0 discriminator 2
 3881 0928 78349FE5 		ldr	r3, .L68+8
 3882 092c 003093E5 		ldr	r3, [r3, #0]
 3883 0930 0320A0E1 		mov	r2, r3
 3884 0934 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3885 0938 0312A0E1 		mov	r1, r3, asl #4
 3886 093c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3887 0940 033081E0 		add	r3, r1, r3
 3888 0944 8330A0E1 		mov	r3, r3, asl #1
 3889 0948 033082E0 		add	r3, r2, r3
 3890 094c 0300A0E1 		mov	r0, r3
 3891 0950 08FEFFEB 		bl	celda_limpiar_error
 220:../button.c   ****                                         for (c = 0; c < NUM_COLUMNAS; c++)
 3892              		.loc 1 220 0 discriminator 2
 3893 0954 0E305BE5 		ldrb	r3, [fp, #-14]
 3894 0958 013083E2 		add	r3, r3, #1
 3895 095c 0E304BE5 		strb	r3, [fp, #-14]
 3896              	.L50:
 220:../button.c   ****                                         for (c = 0; c < NUM_COLUMNAS; c++)
 3897              		.loc 1 220 0 is_stmt 0 discriminator 1
 3898 0960 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3899 0964 0F0053E3 		cmp	r3, #15
 3900 0968 EEFFFF9A 		bls	.L51
 218:../button.c   ****                                 for (f = 0; f < NUM_FILAS; f++)
 3901              		.loc 1 218 0 is_stmt 1
 3902 096c 0D305BE5 		ldrb	r3, [fp, #-13]
 3903 0970 013083E2 		add	r3, r3, #1
 3904 0974 0D304BE5 		strb	r3, [fp, #-13]
 3905              	.L49:
 218:../button.c   ****                                 for (f = 0; f < NUM_FILAS; f++)
 3906              		.loc 1 218 0 is_stmt 0 discriminator 1
 3907 0978 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3908 097c 080053E3 		cmp	r3, #8
 3909 0980 E5FFFF9A 		bls	.L52
 223:../button.c   ****                                         }
 224:../button.c   ****                                 }
 225:../button.c   ****                                 
 226:../button.c   ****                                 /* Borrar el valor de la celda */
 227:../button.c   ****                                 celda_poner_valor(&cuadricula[fila][columna], 0);
 3910              		.loc 1 227 0 is_stmt 1
 3911 0984 1C349FE5 		ldr	r3, .L68+8
 3912 0988 003093E5 		ldr	r3, [r3, #0]
 3913 098c 0320A0E1 		mov	r2, r3
 3914 0990 24349FE5 		ldr	r3, .L68+28
 3915 0994 0030D3E5 		ldrb	r3, [r3, #0]
 3916 0998 FF3003E2 		and	r3, r3, #255
 3917 099c 0312A0E1 		mov	r1, r3, asl #4
 3918 09a0 18349FE5 		ldr	r3, .L68+32
 3919 09a4 0030D3E5 		ldrb	r3, [r3, #0]
 3920 09a8 FF3003E2 		and	r3, r3, #255
 3921 09ac 033081E0 		add	r3, r1, r3
 3922 09b0 8330A0E1 		mov	r3, r3, asl #1
 3923 09b4 033082E0 		add	r3, r2, r3
 3924 09b8 0300A0E1 		mov	r0, r3
 3925 09bc 0010A0E3 		mov	r1, #0
 3926 09c0 8EFDFFEB 		bl	celda_poner_valor
 228:../button.c   ****                                 
 229:../button.c   ****                                 /* Al borrar un valor, hay que recalcular todos los candidatos */
 230:../button.c   ****                                 celdas_vacias = candidatos_actualizar_all(cuadricula);
 3927              		.loc 1 230 0
 3928 09c4 DC339FE5 		ldr	r3, .L68+8
 3929 09c8 003093E5 		ldr	r3, [r3, #0]
 3930 09cc 0300A0E1 		mov	r0, r3
 3931 09d0 FEFFFFEB 		bl	candidatos_actualizar_all
 3932 09d4 0020A0E1 		mov	r2, r0
 3933 09d8 CC339FE5 		ldr	r3, .L68+12
 3934 09dc 002083E5 		str	r2, [r3, #0]
 231:../button.c   ****                                 
 232:../button.c   ****                                 /* Actualizar la visualización del tablero */
 233:../button.c   ****                                 Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3935              		.loc 1 233 0
 3936 09e0 C0339FE5 		ldr	r3, .L68+8
 3937 09e4 003093E5 		ldr	r3, [r3, #0]
 3938 09e8 0300A0E1 		mov	r0, r3
 3939 09ec FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 234:../button.c   ****                                 
 235:../button.c   ****                                 /* Volver a introducir fila */
 236:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3940              		.loc 1 236 0
 3941 09f0 A8339FE5 		ldr	r3, .L68
 3942 09f4 0120A0E3 		mov	r2, #1
 3943 09f8 0020C3E5 		strb	r2, [r3, #0]
 237:../button.c   ****                                 int_count = 9;  /* Iniciar en 9 para que al incrementar vaya a 0 */
 3944              		.loc 1 237 0
 3945 09fc AC339FE5 		ldr	r3, .L68+16
 3946 0a00 0920A0E3 		mov	r2, #9
 3947 0a04 0020C3E5 		strb	r2, [r3, #0]
 238:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3948              		.loc 1 238 0
 3949 0a08 0F00A0E3 		mov	r0, #15
 3950 0a0c FEFFFFEB 		bl	D8Led_symbol
 239:../button.c   ****                                 break;
 3951              		.loc 1 239 0
 3952 0a10 DF0000EA 		b	.L26
 3953              	.L48:
 3954              	.LBE2:
 240:../button.c   ****                         }
 241:../button.c   ****                         else
 242:../button.c   ****                         {
 243:../button.c   ****                                 /* Verificar si el valor es candidato */
 244:../button.c   ****                                 if (celda_es_candidato(cuadricula[fila][columna], valor))
 3955              		.loc 1 244 0
 3956 0a14 8C339FE5 		ldr	r3, .L68+8
 3957 0a18 002093E5 		ldr	r2, [r3, #0]
 3958 0a1c 98339FE5 		ldr	r3, .L68+28
 3959 0a20 0030D3E5 		ldrb	r3, [r3, #0]
 3960 0a24 FF3003E2 		and	r3, r3, #255
 3961 0a28 8332A0E1 		mov	r3, r3, asl #5
 3962 0a2c 032082E0 		add	r2, r2, r3
 3963 0a30 88339FE5 		ldr	r3, .L68+32
 3964 0a34 0030D3E5 		ldrb	r3, [r3, #0]
 3965 0a38 FF3003E2 		and	r3, r3, #255
 3966 0a3c 8330A0E1 		mov	r3, r3, asl #1
 3967 0a40 033082E0 		add	r3, r2, r3
 3968 0a44 B020D3E1 		ldrh	r2, [r3, #0]
 3969 0a48 74339FE5 		ldr	r3, .L68+36
 3970 0a4c 0030D3E5 		ldrb	r3, [r3, #0]
 3971 0a50 FF3003E2 		and	r3, r3, #255
 3972 0a54 0200A0E1 		mov	r0, r2
 3973 0a58 0310A0E1 		mov	r1, r3
 3974 0a5c 93FDFFEB 		bl	celda_es_candidato
 3975 0a60 0030A0E1 		mov	r3, r0
 3976 0a64 000053E3 		cmp	r3, #0
 3977 0a68 5500000A 		beq	.L53
 3978              	.LBB3:
 245:../button.c   ****                                 {
 246:../button.c   ****                                         uint8_t f, c;
 247:../button.c   ****                                         
 248:../button.c   ****                                         /* Es candidato: escribir el valor en la celda */
 249:../button.c   ****                                         /* Primero limpiar todos los errores previos */
 250:../button.c   ****                                         for (f = 0; f < NUM_FILAS; f++)
 3979              		.loc 1 250 0
 3980 0a6c 0030A0E3 		mov	r3, #0
 3981 0a70 0F304BE5 		strb	r3, [fp, #-15]
 3982 0a74 160000EA 		b	.L54
 3983              	.L57:
 251:../button.c   ****                                         {
 252:../button.c   ****                                                 for (c = 0; c < NUM_COLUMNAS; c++)
 3984              		.loc 1 252 0
 3985 0a78 0030A0E3 		mov	r3, #0
 3986 0a7c 10304BE5 		strb	r3, [fp, #-16]
 3987 0a80 0D0000EA 		b	.L55
 3988              	.L56:
 253:../button.c   ****                                                 {
 254:../button.c   ****                                                         celda_limpiar_error(&cuadricula[f][c]);
 3989              		.loc 1 254 0 discriminator 2
 3990 0a84 1C339FE5 		ldr	r3, .L68+8
 3991 0a88 003093E5 		ldr	r3, [r3, #0]
 3992 0a8c 0320A0E1 		mov	r2, r3
 3993 0a90 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3994 0a94 0312A0E1 		mov	r1, r3, asl #4
 3995 0a98 10305BE5 		ldrb	r3, [fp, #-16]	@ zero_extendqisi2
 3996 0a9c 033081E0 		add	r3, r1, r3
 3997 0aa0 8330A0E1 		mov	r3, r3, asl #1
 3998 0aa4 033082E0 		add	r3, r2, r3
 3999 0aa8 0300A0E1 		mov	r0, r3
 4000 0aac B1FDFFEB 		bl	celda_limpiar_error
 252:../button.c   ****                                                 for (c = 0; c < NUM_COLUMNAS; c++)
 4001              		.loc 1 252 0 discriminator 2
 4002 0ab0 10305BE5 		ldrb	r3, [fp, #-16]
 4003 0ab4 013083E2 		add	r3, r3, #1
 4004 0ab8 10304BE5 		strb	r3, [fp, #-16]
 4005              	.L55:
 252:../button.c   ****                                                 for (c = 0; c < NUM_COLUMNAS; c++)
 4006              		.loc 1 252 0 is_stmt 0 discriminator 1
 4007 0abc 10305BE5 		ldrb	r3, [fp, #-16]	@ zero_extendqisi2
 4008 0ac0 0F0053E3 		cmp	r3, #15
 4009 0ac4 EEFFFF9A 		bls	.L56
 250:../button.c   ****                                         for (f = 0; f < NUM_FILAS; f++)
 4010              		.loc 1 250 0 is_stmt 1
 4011 0ac8 0F305BE5 		ldrb	r3, [fp, #-15]
 4012 0acc 013083E2 		add	r3, r3, #1
 4013 0ad0 0F304BE5 		strb	r3, [fp, #-15]
 4014              	.L54:
 250:../button.c   ****                                         for (f = 0; f < NUM_FILAS; f++)
 4015              		.loc 1 250 0 is_stmt 0 discriminator 1
 4016 0ad4 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 4017 0ad8 080053E3 		cmp	r3, #8
 4018 0adc E5FFFF9A 		bls	.L57
 255:../button.c   ****                                                 }
 256:../button.c   ****                                         }
 257:../button.c   ****                                         
 258:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 4019              		.loc 1 258 0 is_stmt 1
 4020 0ae0 C0329FE5 		ldr	r3, .L68+8
 4021 0ae4 003093E5 		ldr	r3, [r3, #0]
 4022 0ae8 0320A0E1 		mov	r2, r3
 4023 0aec C8329FE5 		ldr	r3, .L68+28
 4024 0af0 0030D3E5 		ldrb	r3, [r3, #0]
 4025 0af4 FF3003E2 		and	r3, r3, #255
 4026 0af8 0312A0E1 		mov	r1, r3, asl #4
 4027 0afc BC329FE5 		ldr	r3, .L68+32
 4028 0b00 0030D3E5 		ldrb	r3, [r3, #0]
 4029 0b04 FF3003E2 		and	r3, r3, #255
 4030 0b08 033081E0 		add	r3, r1, r3
 4031 0b0c 8330A0E1 		mov	r3, r3, asl #1
 4032 0b10 032082E0 		add	r2, r2, r3
 4033 0b14 A8329FE5 		ldr	r3, .L68+36
 4034 0b18 0030D3E5 		ldrb	r3, [r3, #0]
 4035 0b1c FF3003E2 		and	r3, r3, #255
 4036 0b20 0200A0E1 		mov	r0, r2
 4037 0b24 0310A0E1 		mov	r1, r3
 4038 0b28 34FDFFEB 		bl	celda_poner_valor
 259:../button.c   ****                                         
 260:../button.c   ****                                         /* Decidir si propagar o actualizar según el caso */
 261:../button.c   ****                                         if (valor_previo != 0)
 4039              		.loc 1 261 0
 4040 0b2c 94329FE5 		ldr	r3, .L68+40
 4041 0b30 0030D3E5 		ldrb	r3, [r3, #0]
 4042 0b34 FF3003E2 		and	r3, r3, #255
 4043 0b38 000053E3 		cmp	r3, #0
 4044 0b3c 0700000A 		beq	.L58
 262:../button.c   ****                                         {
 263:../button.c   ****                                                 /* Se modificó un valor previo -> recalcular todo 
 264:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 4045              		.loc 1 264 0
 4046 0b40 60329FE5 		ldr	r3, .L68+8
 4047 0b44 003093E5 		ldr	r3, [r3, #0]
 4048 0b48 0300A0E1 		mov	r0, r3
 4049 0b4c FEFFFFEB 		bl	candidatos_actualizar_all
 4050 0b50 0020A0E1 		mov	r2, r0
 4051 0b54 50329FE5 		ldr	r3, .L68+12
 4052 0b58 002083E5 		str	r2, [r3, #0]
 4053 0b5c 0B0000EA 		b	.L59
 4054              	.L58:
 265:../button.c   ****                                         }
 266:../button.c   ****                                         else
 267:../button.c   ****                                         {
 268:../button.c   ****                                                 /* Celda vacía -> solo propagar el nuevo valor */
 269:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 4055              		.loc 1 269 0
 4056 0b60 40329FE5 		ldr	r3, .L68+8
 4057 0b64 001093E5 		ldr	r1, [r3, #0]
 4058 0b68 4C329FE5 		ldr	r3, .L68+28
 4059 0b6c 0030D3E5 		ldrb	r3, [r3, #0]
 4060 0b70 FF2003E2 		and	r2, r3, #255
 4061 0b74 44329FE5 		ldr	r3, .L68+32
 4062 0b78 0030D3E5 		ldrb	r3, [r3, #0]
 4063 0b7c FF3003E2 		and	r3, r3, #255
 4064 0b80 0100A0E1 		mov	r0, r1
 4065 0b84 0210A0E1 		mov	r1, r2
 4066 0b88 0320A0E1 		mov	r2, r3
 4067 0b8c FEFFFFEB 		bl	candidatos_propagar_arm
 4068              	.L59:
 270:../button.c   ****                                         }
 271:../button.c   ****                                         
 272:../button.c   ****                                         /* Actualizar la visualización del tablero */
 273:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 4069              		.loc 1 273 0
 4070 0b90 10329FE5 		ldr	r3, .L68+8
 4071 0b94 003093E5 		ldr	r3, [r3, #0]
 4072 0b98 0300A0E1 		mov	r0, r3
 4073 0b9c FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 274:../button.c   ****                                         
 275:../button.c   ****                                         /* Volver a introducir fila */
 276:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 4074              		.loc 1 276 0
 4075 0ba0 F8319FE5 		ldr	r3, .L68
 4076 0ba4 0120A0E3 		mov	r2, #1
 4077 0ba8 0020C3E5 		strb	r2, [r3, #0]
 277:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 4078              		.loc 1 277 0
 4079 0bac FC319FE5 		ldr	r3, .L68+16
 4080 0bb0 0920A0E3 		mov	r2, #9
 4081 0bb4 0020C3E5 		strb	r2, [r3, #0]
 278:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 4082              		.loc 1 278 0
 4083 0bb8 0F00A0E3 		mov	r0, #15
 4084 0bbc FEFFFFEB 		bl	D8Led_symbol
 4085              	.LBE3:
 279:../button.c   ****                                 }
 280:../button.c   ****                                 else
 281:../button.c   ****                                 {
 282:../button.c   ****                                         /* No es candidato: es un error */
 283:../button.c   ****                                         celda_marcar_error(&cuadricula[fila][columna]);
 284:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 285:../button.c   ****                                         
 286:../button.c   ****                                         /* Poner el valor incorrecto en la celda para visualizarlo 
 287:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 288:../button.c   ****                                         
 289:../button.c   ****                                         /* Actualizar candidatos para reflejar el cambio */
 290:../button.c   ****                                         if (valor_previo != 0)
 291:../button.c   ****                                         {
 292:../button.c   ****                                                 /* Se modificó un valor previo -> recalcular todo 
 293:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 294:../button.c   ****                                         }
 295:../button.c   ****                                         else
 296:../button.c   ****                                         {
 297:../button.c   ****                                                 /* Celda vacía -> propagar el nuevo valor */
 298:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 299:../button.c   ****                                         }
 300:../button.c   ****                                         
 301:../button.c   ****                                         /* Marcar TODAS las celdas involucradas en el conflicto */
 302:../button.c   ****                                         marcar_celdas_en_conflicto(fila, columna, valor);
 303:../button.c   ****                                         
 304:../button.c   ****                                         /* Actualizar la visualización del tablero */
 305:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 306:../button.c   ****                                         
 307:../button.c   ****                                         /* Volver a introducir fila */
 308:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 309:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 310:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 311:../button.c   ****                                 }
 312:../button.c   ****                         }
 313:../button.c   ****                         break;
 4086              		.loc 1 313 0
 4087 0bc0 730000EA 		b	.L26
 4088              	.L53:
 283:../button.c   ****                                         celda_marcar_error(&cuadricula[fila][columna]);
 4089              		.loc 1 283 0
 4090 0bc4 DC319FE5 		ldr	r3, .L68+8
 4091 0bc8 003093E5 		ldr	r3, [r3, #0]
 4092 0bcc 0320A0E1 		mov	r2, r3
 4093 0bd0 E4319FE5 		ldr	r3, .L68+28
 4094 0bd4 0030D3E5 		ldrb	r3, [r3, #0]
 4095 0bd8 FF3003E2 		and	r3, r3, #255
 4096 0bdc 0312A0E1 		mov	r1, r3, asl #4
 4097 0be0 D8319FE5 		ldr	r3, .L68+32
 4098 0be4 0030D3E5 		ldrb	r3, [r3, #0]
 4099 0be8 FF3003E2 		and	r3, r3, #255
 4100 0bec 033081E0 		add	r3, r1, r3
 4101 0bf0 8330A0E1 		mov	r3, r3, asl #1
 4102 0bf4 033082E0 		add	r3, r2, r3
 4103 0bf8 0300A0E1 		mov	r0, r3
 4104 0bfc 4EFDFFEB 		bl	celda_marcar_error
 284:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 4105              		.loc 1 284 0
 4106 0c00 0E00A0E3 		mov	r0, #14
 4107 0c04 FEFFFFEB 		bl	D8Led_symbol
 287:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 4108              		.loc 1 287 0
 4109 0c08 98319FE5 		ldr	r3, .L68+8
 4110 0c0c 003093E5 		ldr	r3, [r3, #0]
 4111 0c10 0320A0E1 		mov	r2, r3
 4112 0c14 A0319FE5 		ldr	r3, .L68+28
 4113 0c18 0030D3E5 		ldrb	r3, [r3, #0]
 4114 0c1c FF3003E2 		and	r3, r3, #255
 4115 0c20 0312A0E1 		mov	r1, r3, asl #4
 4116 0c24 94319FE5 		ldr	r3, .L68+32
 4117 0c28 0030D3E5 		ldrb	r3, [r3, #0]
 4118 0c2c FF3003E2 		and	r3, r3, #255
 4119 0c30 033081E0 		add	r3, r1, r3
 4120 0c34 8330A0E1 		mov	r3, r3, asl #1
 4121 0c38 032082E0 		add	r2, r2, r3
 4122 0c3c 80319FE5 		ldr	r3, .L68+36
 4123 0c40 0030D3E5 		ldrb	r3, [r3, #0]
 4124 0c44 FF3003E2 		and	r3, r3, #255
 4125 0c48 0200A0E1 		mov	r0, r2
 4126 0c4c 0310A0E1 		mov	r1, r3
 4127 0c50 EAFCFFEB 		bl	celda_poner_valor
 290:../button.c   ****                                         if (valor_previo != 0)
 4128              		.loc 1 290 0
 4129 0c54 6C319FE5 		ldr	r3, .L68+40
 4130 0c58 0030D3E5 		ldrb	r3, [r3, #0]
 4131 0c5c FF3003E2 		and	r3, r3, #255
 4132 0c60 000053E3 		cmp	r3, #0
 4133 0c64 0700000A 		beq	.L61
 293:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 4134              		.loc 1 293 0
 4135 0c68 38319FE5 		ldr	r3, .L68+8
 4136 0c6c 003093E5 		ldr	r3, [r3, #0]
 4137 0c70 0300A0E1 		mov	r0, r3
 4138 0c74 FEFFFFEB 		bl	candidatos_actualizar_all
 4139 0c78 0020A0E1 		mov	r2, r0
 4140 0c7c 28319FE5 		ldr	r3, .L68+12
 4141 0c80 002083E5 		str	r2, [r3, #0]
 4142 0c84 0B0000EA 		b	.L62
 4143              	.L61:
 298:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 4144              		.loc 1 298 0
 4145 0c88 18319FE5 		ldr	r3, .L68+8
 4146 0c8c 001093E5 		ldr	r1, [r3, #0]
 4147 0c90 24319FE5 		ldr	r3, .L68+28
 4148 0c94 0030D3E5 		ldrb	r3, [r3, #0]
 4149 0c98 FF2003E2 		and	r2, r3, #255
 4150 0c9c 1C319FE5 		ldr	r3, .L68+32
 4151 0ca0 0030D3E5 		ldrb	r3, [r3, #0]
 4152 0ca4 FF3003E2 		and	r3, r3, #255
 4153 0ca8 0100A0E1 		mov	r0, r1
 4154 0cac 0210A0E1 		mov	r1, r2
 4155 0cb0 0320A0E1 		mov	r2, r3
 4156 0cb4 FEFFFFEB 		bl	candidatos_propagar_arm
 4157              	.L62:
 302:../button.c   ****                                         marcar_celdas_en_conflicto(fila, columna, valor);
 4158              		.loc 1 302 0
 4159 0cb8 FC309FE5 		ldr	r3, .L68+28
 4160 0cbc 0030D3E5 		ldrb	r3, [r3, #0]
 4161 0cc0 FF1003E2 		and	r1, r3, #255
 4162 0cc4 F4309FE5 		ldr	r3, .L68+32
 4163 0cc8 0030D3E5 		ldrb	r3, [r3, #0]
 4164 0ccc FF2003E2 		and	r2, r3, #255
 4165 0cd0 EC309FE5 		ldr	r3, .L68+36
 4166 0cd4 0030D3E5 		ldrb	r3, [r3, #0]
 4167 0cd8 FF3003E2 		and	r3, r3, #255
 4168 0cdc 0100A0E1 		mov	r0, r1
 4169 0ce0 0210A0E1 		mov	r1, r2
 4170 0ce4 0320A0E1 		mov	r2, r3
 4171 0ce8 31FDFFEB 		bl	marcar_celdas_en_conflicto
 305:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 4172              		.loc 1 305 0
 4173 0cec B4309FE5 		ldr	r3, .L68+8
 4174 0cf0 003093E5 		ldr	r3, [r3, #0]
 4175 0cf4 0300A0E1 		mov	r0, r3
 4176 0cf8 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 308:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 4177              		.loc 1 308 0
 4178 0cfc 9C309FE5 		ldr	r3, .L68
 4179 0d00 0120A0E3 		mov	r2, #1
 4180 0d04 0020C3E5 		strb	r2, [r3, #0]
 309:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 4181              		.loc 1 309 0
 4182 0d08 A0309FE5 		ldr	r3, .L68+16
 4183 0d0c 0920A0E3 		mov	r2, #9
 4184 0d10 0020C3E5 		strb	r2, [r3, #0]
 310:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 4185              		.loc 1 310 0
 4186 0d14 0F00A0E3 		mov	r0, #15
 4187 0d18 FEFFFFEB 		bl	D8Led_symbol
 4188              		.loc 1 313 0
 4189 0d1c 1C0000EA 		b	.L26
 4190              	.L34:
 314:../button.c   ****                 
 315:../button.c   ****                 case PARTIDA_TERMINADA:
 316:../button.c   ****                         /* Mostrar pantalla de despedida solo una vez */
 317:../button.c   ****                         if (!pantalla_mostrada)
 4191              		.loc 1 317 0
 4192 0d20 8C309FE5 		ldr	r3, .L68+20
 4193 0d24 0030D3E5 		ldrb	r3, [r3, #0]
 4194 0d28 FF3003E2 		and	r3, r3, #255
 4195 0d2c 000053E3 		cmp	r3, #0
 4196 0d30 0700001A 		bne	.L63
 318:../button.c   ****                         {
 319:../button.c   ****                                 /* Usar la función existente de lcd.c */
 320:../button.c   ****                                 Sudoku_Pantalla_Final(tiempo_final);
 4197              		.loc 1 320 0
 4198 0d34 7C309FE5 		ldr	r3, .L68+24
 4199 0d38 003093E5 		ldr	r3, [r3, #0]
 4200 0d3c 0300A0E1 		mov	r0, r3
 4201 0d40 FEFFFFEB 		bl	Sudoku_Pantalla_Final
 321:../button.c   ****                                 
 322:../button.c   ****                                 pantalla_mostrada = 1;
 4202              		.loc 1 322 0
 4203 0d44 68309FE5 		ldr	r3, .L68+20
 4204 0d48 0120A0E3 		mov	r2, #1
 4205 0d4c 0020C3E5 		strb	r2, [r3, #0]
 323:../button.c   ****                         }
 324:../button.c   ****                         else
 325:../button.c   ****                         {
 326:../button.c   ****                                 /* Cualquier botón después de mostrar pantalla final reinicia el 
 327:../button.c   ****                                 /* Mostrar pantalla inicial */
 328:../button.c   ****                                 Sudoku_Pantalla_Inicial();
 329:../button.c   ****                                 
 330:../button.c   ****                                 /* Volver al estado inicial */
 331:../button.c   ****                                 estado_juego = ESPERANDO_INICIO;
 332:../button.c   ****                                 int_count = 0;
 333:../button.c   ****                                 pantalla_mostrada = 0;
 334:../button.c   ****                         }
 335:../button.c   ****                         break;
 4206              		.loc 1 335 0
 4207 0d50 0F0000EA 		b	.L26
 4208              	.L63:
 328:../button.c   ****                                 Sudoku_Pantalla_Inicial();
 4209              		.loc 1 328 0
 4210 0d54 FEFFFFEB 		bl	Sudoku_Pantalla_Inicial
 331:../button.c   ****                                 estado_juego = ESPERANDO_INICIO;
 4211              		.loc 1 331 0
 4212 0d58 40309FE5 		ldr	r3, .L68
 4213 0d5c 0020A0E3 		mov	r2, #0
 4214 0d60 0020C3E5 		strb	r2, [r3, #0]
 332:../button.c   ****                                 int_count = 0;
 4215              		.loc 1 332 0
 4216 0d64 44309FE5 		ldr	r3, .L68+16
 4217 0d68 0020A0E3 		mov	r2, #0
 4218 0d6c 0020C3E5 		strb	r2, [r3, #0]
 333:../button.c   ****                                 pantalla_mostrada = 0;
 4219              		.loc 1 333 0
 4220 0d70 3C309FE5 		ldr	r3, .L68+20
 4221 0d74 0020A0E3 		mov	r2, #0
 4222 0d78 0020C3E5 		strb	r2, [r3, #0]
 4223              		.loc 1 335 0
 4224 0d7c 040000EA 		b	.L26
 4225              	.L65:
 147:../button.c   ****                         break;
 4226              		.loc 1 147 0
 4227 0d80 0000A0E1 		mov	r0, r0	@ nop
 4228 0d84 020000EA 		b	.L26
 4229              	.L66:
 168:../button.c   ****                         break;
 4230              		.loc 1 168 0
 4231 0d88 0000A0E1 		mov	r0, r0	@ nop
 4232 0d8c 000000EA 		b	.L26
 4233              	.L67:
 206:../button.c   ****                         break;
 4234              		.loc 1 206 0
 4235 0d90 0000A0E1 		mov	r0, r0	@ nop
 4236              	.L26:
 336:../button.c   ****         }
 337:../button.c   **** }
 4237              		.loc 1 337 0
 4238 0d94 0CD04BE2 		sub	sp, fp, #12
 4239 0d98 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4240 0d9c 1EFF2FE1 		bx	lr
 4241              	.L69:
 4242              		.align	2
 4243              	.L68:
 4244 0da0 00000000 		.word	estado_juego
 4245 0da4 08000000 		.word	tiempo_inicio
 4246 0da8 00000000 		.word	cuadricula
 4247 0dac 00000000 		.word	celdas_vacias
 4248 0db0 01000000 		.word	int_count
 4249 0db4 06000000 		.word	pantalla_mostrada
 4250 0db8 0C000000 		.word	tiempo_final
 4251 0dbc 02000000 		.word	fila
 4252 0dc0 03000000 		.word	columna
 4253 0dc4 04000000 		.word	valor
 4254 0dc8 05000000 		.word	valor_previo
 4255              		.cfi_endproc
 4256              	.LFE8:
 4258              		.align	2
 4259              		.global	Eint4567_ISR
 4261              	Eint4567_ISR:
 4262              	.LFB9:
 338:../button.c   **** 
 339:../button.c   **** /* declaración de función que es rutina de servicio de interrupción
 340:../button.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
 341:../button.c   **** void Eint4567_ISR(void) __attribute__((interrupt("IRQ")));
 342:../button.c   **** 
 343:../button.c   **** /*--- código de funciones ---*/
 344:../button.c   **** void Eint4567_ISR(void)
 345:../button.c   **** {
 4263              		.loc 1 345 0
 4264              		.cfi_startproc
 4265              		@ Interrupt Service Routine.
 4266              		@ args = 0, pretend = 0, frame = 8
 4267              		@ frame_needed = 1, uses_anonymous_args = 0
 4268 0dcc 04C02DE5 		str	ip, [sp, #-4]!
 4269 0dd0 0DC0A0E1 		mov	ip, sp
 4270              	.LCFI16:
 4271              		.cfi_def_cfa_register 12
 4272 0dd4 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 4273 0dd8 04B04CE2 		sub	fp, ip, #4
 4274              		.cfi_offset 14, -8
 4275              		.cfi_offset 13, -12
 4276              		.cfi_offset 11, -16
 4277              		.cfi_offset 3, -20
 4278              		.cfi_offset 2, -24
 4279              		.cfi_offset 1, -28
 4280              		.cfi_offset 0, -32
 4281              	.LCFI17:
 4282              		.cfi_def_cfa 11, 4
 4283 0ddc 08D04DE2 		sub	sp, sp, #8
 346:../button.c   ****         /* Identificar la interrupción (hay dos pulsadores) */
 347:../button.c   ****         unsigned int pending = rEXTINTPND & 0xF;
 4284              		.loc 1 347 0
 4285 0de0 8C309FE5 		ldr	r3, .L74
 4286 0de4 003093E5 		ldr	r3, [r3, #0]
 4287 0de8 0F3003E2 		and	r3, r3, #15
 4288 0dec 24300BE5 		str	r3, [fp, #-36]
 348:../button.c   ****         uint8_t boton_id = 0;
 4289              		.loc 1 348 0
 4290 0df0 0030A0E3 		mov	r3, #0
 4291 0df4 1D304BE5 		strb	r3, [fp, #-29]
 349:../button.c   **** 
 350:../button.c   ****         if (pending & 0x4)
 4292              		.loc 1 350 0
 4293 0df8 24301BE5 		ldr	r3, [fp, #-36]
 4294 0dfc 043003E2 		and	r3, r3, #4
 4295 0e00 000053E3 		cmp	r3, #0
 4296 0e04 0200000A 		beq	.L71
 351:../button.c   ****         {
 352:../button.c   ****                 boton_id = EVENTO_BOTON_IZQUIERDO;
 4297              		.loc 1 352 0
 4298 0e08 0430A0E3 		mov	r3, #4
 4299 0e0c 1D304BE5 		strb	r3, [fp, #-29]
 4300 0e10 050000EA 		b	.L72
 4301              	.L71:
 353:../button.c   ****         }
 354:../button.c   ****         else if (pending & 0x8)
 4302              		.loc 1 354 0
 4303 0e14 24301BE5 		ldr	r3, [fp, #-36]
 4304 0e18 083003E2 		and	r3, r3, #8
 4305 0e1c 000053E3 		cmp	r3, #0
 4306 0e20 0100000A 		beq	.L72
 355:../button.c   ****         {
 356:../button.c   ****                 boton_id = EVENTO_BOTON_DERECHO;
 4307              		.loc 1 356 0
 4308 0e24 0830A0E3 		mov	r3, #8
 4309 0e28 1D304BE5 		strb	r3, [fp, #-29]
 4310              	.L72:
 357:../button.c   ****         }
 358:../button.c   **** 
 359:../button.c   ****         if (boton_id != 0U)
 4311              		.loc 1 359 0
 4312 0e2c 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 4313 0e30 000053E3 		cmp	r3, #0
 4314 0e34 0200000A 		beq	.L73
 360:../button.c   ****         {
 361:../button.c   ****                 /* No registrar la pulsación inicial, solo las confirmadas */
 362:../button.c   **** 
 363:../button.c   ****                 /* Iniciar la máquina de antirrebotes. Si está ocupada, no hacer nada */
 364:../button.c   ****                 timer3_start_antirrebote(boton_id);
 4315              		.loc 1 364 0
 4316 0e38 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 4317 0e3c 0300A0E1 		mov	r0, r3
 4318 0e40 FEFFFFEB 		bl	timer3_start_antirrebote
 4319              	.L73:
 365:../button.c   ****         }
 366:../button.c   **** 
 367:../button.c   ****         /* Finalizar ISR */
 368:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 4320              		.loc 1 368 0
 4321 0e44 28309FE5 		ldr	r3, .L74
 4322 0e48 0F20A0E3 		mov	r2, #15
 4323 0e4c 002083E5 		str	r2, [r3, #0]
 369:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 4324              		.loc 1 369 0
 4325 0e50 20309FE5 		ldr	r3, .L74+4
 4326 0e54 1C209FE5 		ldr	r2, .L74+4
 4327 0e58 002092E5 		ldr	r2, [r2, #0]
 4328 0e5c 022682E3 		orr	r2, r2, #2097152
 4329 0e60 002083E5 		str	r2, [r3, #0]
 370:../button.c   **** }
 4330              		.loc 1 370 0
 4331 0e64 1CD04BE2 		sub	sp, fp, #28
 4332 0e68 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 4333 0e6c 04C09DE4 		ldmfd	sp!, {ip}
 4334 0e70 04F05EE2 		subs	pc, lr, #4
 4335              	.L75:
 4336              		.align	2
 4337              	.L74:
 4338 0e74 5400D201 		.word	30539860
 4339 0e78 2400E001 		.word	31457316
 4340              		.cfi_endproc
 4341              	.LFE9:
 4343              		.align	2
 4344              		.global	Sudoku_Partida_Terminada
 4346              	Sudoku_Partida_Terminada:
 4347              	.LFB10:
 371:../button.c   **** /* Función para consultar si la partida está terminada */
 372:../button.c   **** int Sudoku_Partida_Terminada(void)
 373:../button.c   **** {
 4348              		.loc 1 373 0
 4349              		.cfi_startproc
 4350              		@ Function supports interworking.
 4351              		@ args = 0, pretend = 0, frame = 0
 4352              		@ frame_needed = 1, uses_anonymous_args = 0
 4353 0e7c 0DC0A0E1 		mov	ip, sp
 4354              	.LCFI18:
 4355              		.cfi_def_cfa_register 12
 4356 0e80 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4357 0e84 04B04CE2 		sub	fp, ip, #4
 4358              		.cfi_offset 14, -8
 4359              		.cfi_offset 13, -12
 4360              		.cfi_offset 11, -16
 4361              	.LCFI19:
 4362              		.cfi_def_cfa 11, 4
 374:../button.c   **** 	return (estado_juego == PARTIDA_TERMINADA);
 4363              		.loc 1 374 0
 4364 0e88 20309FE5 		ldr	r3, .L77
 4365 0e8c 0030D3E5 		ldrb	r3, [r3, #0]
 4366 0e90 FF3003E2 		and	r3, r3, #255
 4367 0e94 070053E3 		cmp	r3, #7
 4368 0e98 0030A013 		movne	r3, #0
 4369 0e9c 0130A003 		moveq	r3, #1
 375:../button.c   **** }
 4370              		.loc 1 375 0
 4371 0ea0 0300A0E1 		mov	r0, r3
 4372 0ea4 0CD04BE2 		sub	sp, fp, #12
 4373 0ea8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4374 0eac 1EFF2FE1 		bx	lr
 4375              	.L78:
 4376              		.align	2
 4377              	.L77:
 4378 0eb0 00000000 		.word	estado_juego
 4379              		.cfi_endproc
 4380              	.LFE10:
 4382              		.align	2
 4383              		.global	Sudoku_Juego_En_Progreso
 4385              	Sudoku_Juego_En_Progreso:
 4386              	.LFB11:
 376:../button.c   **** 
 377:../button.c   **** /* Función para consultar si el juego está en progreso */
 378:../button.c   **** int Sudoku_Juego_En_Progreso(void)
 379:../button.c   **** {
 4387              		.loc 1 379 0
 4388              		.cfi_startproc
 4389              		@ Function supports interworking.
 4390              		@ args = 0, pretend = 0, frame = 0
 4391              		@ frame_needed = 1, uses_anonymous_args = 0
 4392 0eb4 0DC0A0E1 		mov	ip, sp
 4393              	.LCFI20:
 4394              		.cfi_def_cfa_register 12
 4395 0eb8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4396 0ebc 04B04CE2 		sub	fp, ip, #4
 4397              		.cfi_offset 14, -8
 4398              		.cfi_offset 13, -12
 4399              		.cfi_offset 11, -16
 4400              	.LCFI21:
 4401              		.cfi_def_cfa 11, 4
 380:../button.c   **** 	return (estado_juego != ESPERANDO_INICIO && estado_juego != PARTIDA_TERMINADA);
 4402              		.loc 1 380 0
 4403 0ec0 3C309FE5 		ldr	r3, .L82
 4404 0ec4 0030D3E5 		ldrb	r3, [r3, #0]
 4405 0ec8 FF3003E2 		and	r3, r3, #255
 4406 0ecc 000053E3 		cmp	r3, #0
 4407 0ed0 0600000A 		beq	.L80
 4408              		.loc 1 380 0 is_stmt 0 discriminator 1
 4409 0ed4 28309FE5 		ldr	r3, .L82
 4410 0ed8 0030D3E5 		ldrb	r3, [r3, #0]
 4411 0edc FF3003E2 		and	r3, r3, #255
 4412 0ee0 070053E3 		cmp	r3, #7
 4413 0ee4 0100000A 		beq	.L80
 4414 0ee8 0130A0E3 		mov	r3, #1
 4415 0eec 000000EA 		b	.L81
 4416              	.L80:
 4417              		.loc 1 380 0 discriminator 2
 4418 0ef0 0030A0E3 		mov	r3, #0
 4419              	.L81:
 381:../button.c   **** }
 4420              		.loc 1 381 0 is_stmt 1 discriminator 3
 4421 0ef4 0300A0E1 		mov	r0, r3
 4422 0ef8 0CD04BE2 		sub	sp, fp, #12
 4423 0efc 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4424 0f00 1EFF2FE1 		bx	lr
 4425              	.L83:
 4426              		.align	2
 4427              	.L82:
 4428 0f04 00000000 		.word	estado_juego
 4429              		.cfi_endproc
 4430              	.LFE11:
 4432              		.align	2
 4433              		.global	Sudoku_Obtener_Tiempo_Inicio
 4435              	Sudoku_Obtener_Tiempo_Inicio:
 4436              	.LFB12:
 382:../button.c   **** 
 383:../button.c   **** /* Función para obtener el tiempo de inicio de la partida */
 384:../button.c   **** unsigned int Sudoku_Obtener_Tiempo_Inicio(void)
 385:../button.c   **** {
 4437              		.loc 1 385 0
 4438              		.cfi_startproc
 4439              		@ Function supports interworking.
 4440              		@ args = 0, pretend = 0, frame = 0
 4441              		@ frame_needed = 1, uses_anonymous_args = 0
 4442 0f08 0DC0A0E1 		mov	ip, sp
 4443              	.LCFI22:
 4444              		.cfi_def_cfa_register 12
 4445 0f0c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4446 0f10 04B04CE2 		sub	fp, ip, #4
 4447              		.cfi_offset 14, -8
 4448              		.cfi_offset 13, -12
 4449              		.cfi_offset 11, -16
 4450              	.LCFI23:
 4451              		.cfi_def_cfa 11, 4
 386:../button.c   **** 	return tiempo_inicio;
 4452              		.loc 1 386 0
 4453 0f14 10309FE5 		ldr	r3, .L85
 4454 0f18 003093E5 		ldr	r3, [r3, #0]
 387:../button.c   **** }
 4455              		.loc 1 387 0
 4456 0f1c 0300A0E1 		mov	r0, r3
 4457 0f20 0CD04BE2 		sub	sp, fp, #12
 4458 0f24 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4459 0f28 1EFF2FE1 		bx	lr
 4460              	.L86:
 4461              		.align	2
 4462              	.L85:
 4463 0f2c 08000000 		.word	tiempo_inicio
 4464              		.cfi_endproc
 4465              	.LFE12:
 4467              		.align	2
 4468              		.global	Eint4567_init
 4470              	Eint4567_init:
 4471              	.LFB13:
 388:../button.c   **** void Eint4567_init(void)
 389:../button.c   **** {
 4472              		.loc 1 389 0
 4473              		.cfi_startproc
 4474              		@ Function supports interworking.
 4475              		@ args = 0, pretend = 0, frame = 0
 4476              		@ frame_needed = 1, uses_anonymous_args = 0
 4477 0f30 0DC0A0E1 		mov	ip, sp
 4478              	.LCFI24:
 4479              		.cfi_def_cfa_register 12
 4480 0f34 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4481 0f38 04B04CE2 		sub	fp, ip, #4
 4482              		.cfi_offset 14, -8
 4483              		.cfi_offset 13, -12
 4484              		.cfi_offset 11, -16
 4485              	.LCFI25:
 4486              		.cfi_def_cfa 11, 4
 390:../button.c   ****         /* Inicializar el temporizador dedicado a la eliminación de rebotes */
 391:../button.c   ****         timer3_init(boton_confirmado);
 4487              		.loc 1 391 0
 4488 0f3c AC009FE5 		ldr	r0, .L88
 4489 0f40 FEFFFFEB 		bl	timer3_init
 392:../button.c   **** 
 393:../button.c   ****         /* Configuracion del controlador de interrupciones. Estos registros están definidos en 44b
 394:../button.c   ****         rI_ISPC    = 0x3ffffff;         // Borra INTPND escribiendo 1s en I_ISPC
 4490              		.loc 1 394 0
 4491 0f44 A8309FE5 		ldr	r3, .L88+4
 4492 0f48 3F23E0E3 		mvn	r2, #-67108864
 4493 0f4c 002083E5 		str	r2, [r3, #0]
 395:../button.c   ****         rEXTINTPND = 0xf;               // Borra EXTINTPND escribiendo 1s en el propio registro
 4494              		.loc 1 395 0
 4495 0f50 A0309FE5 		ldr	r3, .L88+8
 4496 0f54 0F20A0E3 		mov	r2, #15
 4497 0f58 002083E5 		str	r2, [r3, #0]
 396:../button.c   ****         rINTMOD    = 0x0;               // Configura las lineas como de tipo IRQ
 4498              		.loc 1 396 0
 4499 0f5c 98309FE5 		ldr	r3, .L88+12
 4500 0f60 0020A0E3 		mov	r2, #0
 4501 0f64 002083E5 		str	r2, [r3, #0]
 397:../button.c   ****         rINTCON    = 0x1;               // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 4502              		.loc 1 397 0
 4503 0f68 1E36A0E3 		mov	r3, #31457280
 4504 0f6c 0120A0E3 		mov	r2, #1
 4505 0f70 002083E5 		str	r2, [r3, #0]
 398:../button.c   ****         rINTMSK    &= ~(BIT_EINT4567);  // habilitamos interrupcion linea eint4567 en vector de mas
 4506              		.loc 1 398 0
 4507 0f74 84309FE5 		ldr	r3, .L88+16
 4508 0f78 80209FE5 		ldr	r2, .L88+16
 4509 0f7c 002092E5 		ldr	r2, [r2, #0]
 4510 0f80 0226C2E3 		bic	r2, r2, #2097152
 4511 0f84 002083E5 		str	r2, [r3, #0]
 399:../button.c   **** 
 400:../button.c   ****         /* Establece la rutina de servicio para Eint4567 */
 401:../button.c   ****         pISR_EINT4567 = (int) Eint4567_ISR;
 4512              		.loc 1 401 0
 4513 0f88 74309FE5 		ldr	r3, .L88+20
 4514 0f8c 74209FE5 		ldr	r2, .L88+24
 4515 0f90 002083E5 		str	r2, [r3, #0]
 402:../button.c   **** 
 403:../button.c   ****         /* Configuracion del puerto G */
 404:../button.c   ****         rPCONG  = 0xffff;                       // Establece la funcion de los pines (EINT0-7)
 4516              		.loc 1 404 0
 4517 0f94 70309FE5 		ldr	r3, .L88+28
 4518 0f98 70209FE5 		ldr	r2, .L88+32
 4519 0f9c 002083E5 		str	r2, [r3, #0]
 405:../button.c   ****         rPUPG   = 0x0;                  // Habilita el "pull up" del puerto
 4520              		.loc 1 405 0
 4521 0fa0 6C309FE5 		ldr	r3, .L88+36
 4522 0fa4 0020A0E3 		mov	r2, #0
 4523 0fa8 002083E5 		str	r2, [r3, #0]
 406:../button.c   ****         rEXTINT = rEXTINT | 0x22222222;   // Configura las lineas de int. como de flanco de bajada
 4524              		.loc 1 406 0
 4525 0fac 64209FE5 		ldr	r2, .L88+40
 4526 0fb0 60309FE5 		ldr	r3, .L88+40
 4527 0fb4 001093E5 		ldr	r1, [r3, #0]
 4528 0fb8 5C309FE5 		ldr	r3, .L88+44
 4529 0fbc 033081E1 		orr	r3, r1, r3
 4530 0fc0 003082E5 		str	r3, [r2, #0]
 407:../button.c   **** 
 408:../button.c   ****         /* Por precaucion, se vuelven a borrar los bits de INTPND y EXTINTPND */
 409:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 4531              		.loc 1 409 0
 4532 0fc4 2C309FE5 		ldr	r3, .L88+8
 4533 0fc8 0F20A0E3 		mov	r2, #15
 4534 0fcc 002083E5 		str	r2, [r3, #0]
 410:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 4535              		.loc 1 410 0
 4536 0fd0 1C309FE5 		ldr	r3, .L88+4
 4537 0fd4 18209FE5 		ldr	r2, .L88+4
 4538 0fd8 002092E5 		ldr	r2, [r2, #0]
 4539 0fdc 022682E3 		orr	r2, r2, #2097152
 4540 0fe0 002083E5 		str	r2, [r3, #0]
 411:../button.c   **** }
 4541              		.loc 1 411 0
 4542 0fe4 0CD04BE2 		sub	sp, fp, #12
 4543 0fe8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4544 0fec 1EFF2FE1 		bx	lr
 4545              	.L89:
 4546              		.align	2
 4547              	.L88:
 4548 0ff0 00000000 		.word	boton_confirmado
 4549 0ff4 2400E001 		.word	31457316
 4550 0ff8 5400D201 		.word	30539860
 4551 0ffc 0800E001 		.word	31457288
 4552 1000 0C00E001 		.word	31457292
 4553 1004 74FF7F0C 		.word	209715060
 4554 1008 00000000 		.word	Eint4567_ISR
 4555 100c 4000D201 		.word	30539840
 4556 1010 FFFF0000 		.word	65535
 4557 1014 4800D201 		.word	30539848
 4558 1018 5000D201 		.word	30539856
 4559 101c 22222222 		.word	572662306
 4560              		.cfi_endproc
 4561              	.LFE13:
 4563              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 button.c
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:2979   .text:00000000 $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:2981   .text:00000000 celda_poner_valor
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3032   .text:00000078 celda_leer_valor
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3067   .text:000000b0 celda_es_candidato
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3108   .text:00000100 celda_es_pista
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3144   .text:0000013c celda_marcar_error
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3180   .text:00000178 celda_limpiar_error
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3215   .bss:00000000 estado_juego
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3216   .bss:00000000 $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3217   .bss:00000001 int_count
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3219   .bss:00000002 fila
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3221   .bss:00000003 columna
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3223   .bss:00000004 valor
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3225   .bss:00000005 valor_previo
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3227   .bss:00000006 pantalla_mostrada
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3230   .bss:00000008 tiempo_inicio
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3233   .bss:0000000c tiempo_final
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3238   .text:000001b4 marcar_celdas_en_conflicto
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3509   .text:000004e8 $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3514   .text:000004f0 $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3516   .text:000004f0 boton_confirmado
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3555   .text:00000548 $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:3565   .text:00000568 $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4244   .text:00000da0 $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4258   .text:00000dcc $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4261   .text:00000dcc Eint4567_ISR
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4338   .text:00000e74 $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4343   .text:00000e7c $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4346   .text:00000e7c Sudoku_Partida_Terminada
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4378   .text:00000eb0 $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4382   .text:00000eb4 $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4385   .text:00000eb4 Sudoku_Juego_En_Progreso
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4428   .text:00000f04 $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4432   .text:00000f08 $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4435   .text:00000f08 Sudoku_Obtener_Tiempo_Inicio
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4463   .text:00000f2c $d
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4467   .text:00000f30 $a
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4470   .text:00000f30 Eint4567_init
C:\Users\jaime\AppData\Local\Temp\ccqMv9ce.s:4548   .text:00000ff0 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
cuadricula
timer2_count
cola_depuracion
candidatos_actualizar_all
Sudoku_Dibujar_Tablero
Sudoku_Actualizar_Tablero_Completo
D8Led_symbol
candidatos_propagar_arm
Sudoku_Pantalla_Final
Sudoku_Pantalla_Inicial
celdas_vacias
timer3_start_antirrebote
timer3_init
